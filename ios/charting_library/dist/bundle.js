/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./broker-sample/lib/broker.js":
/*!*************************************!*\
  !*** ./broker-sample/lib/broker.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BASE_URL: () => (/* binding */ BASE_URL),\n/* harmony export */   BrokerSample: () => (/* binding */ BrokerSample),\n/* harmony export */   OPO_BASE_URL: () => (/* binding */ OPO_BASE_URL)\n/* harmony export */ });\n/* harmony import */ var _columns_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./columns.js */ \"./broker-sample/lib/columns.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ \"./broker-sample/lib/helpers.js\");\n/* harmony import */ var _streaming_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./streaming.js */ \"./broker-sample/lib/streaming.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * @module Make sure that you include Promise polyfill in your bundle to support old browsers\n * @see {@link https://caniuse.com/#search=Promise | Browsers with native Promise support}\n * @see {@link https://www.npmjs.com/package/promise-polyfill | Polyfill}\n */\n/**\n * Imports the objects for columns on the \"Account Summary\", \"Orders\", and \"Positions\" pages\n */\n\n\n//   export const BASE_URL = \"https://oponew-ehhgc5eudvg0fsa8.spaincentral-01.azurewebsites.net/\";\nvar BASE_URL = \"https://opotrade.azurewebsites.net\";\nvar OPO_BASE_URL = \"https://myaccount.opofinance.com\";\n\n/**\n * Defines an array of order statuses, including only \"Inactive\" and \"Working\" statuses.\n * This variable is used to retrieve bracket orders associated with a parent ID in `_getBrackets` function.\n */\nvar activeOrderStatuses = [3 /* OrderStatus.Inactive */, 6 /* OrderStatus.Working */];\nvar loginNumber = 0;\nvar LAST_USED_ACCOUNT_STORAGE_KEY = \"lastUsedAccount\";\n/**\n * The Broker API implementation.\n * The Broker API is a key component that enables trading.\n * Its main purpose is to connect TradingView charts with the trading logic.\n */\nvar BrokerSample = /*#__PURE__*/function () {\n  // private subscriptions: Map<string, any>;\n  function BrokerSample(host, quotesProvider, balanceEquityStreaming) {\n    var _this = this;\n    _classCallCheck(this, BrokerSample);\n    /** Defines the initial values for the custom \"Account Summary\" page in the Account Manager */\n    this._accountManagerData = {\n      title: \"Trading Sample\",\n      balance: 10000000,\n      equity: 10000000,\n      pl: 0\n    };\n    this._accountlist = [];\n    this._positionlist = [];\n    this._orderlist = [];\n    this._orderHistorylist = [];\n    this._symbolDigits = {};\n    /** Initializes an empty map to store positions indexed by their IDs */\n    this._positionById = {};\n    /** Initializes an array to store position data */\n    this._positions = [];\n    /** Initializes an empty map to store orders indexed by their IDs */\n    this._orderById = {};\n    /** Initializes an array to store execution  data */\n    this._executions = [];\n    /** Initializes the counter to 1, used to assign unique IDs to orders and positions */\n    this._idsCounter = 1;\n    this.currentAccountSelected = null;\n    this._activeSymbols = new Set();\n    this._subscribedSymbols = new Set();\n    this._accountSuffixes = new Map();\n    /** Handles updates to the equity value by calling the `equityUpdate` method of the Trading Host */\n    this._handleEquityUpdate = function (value) {\n      _this._host.equityUpdate(value);\n    };\n    this._quotesProvider = quotesProvider;\n    this._host = host;\n    this._balanceEquityStreaming = balanceEquityStreaming;\n    this._plValue = this._host.factory.createWatchedValue(this._accountManagerData.pl);\n    //   this.fetchAccountData();\n    // this.subscriptions = new Map();\n    // Create a delegate object\n    this._amChangeDelegate = this._host.factory.createDelegate();\n    // Create watched values for user's balance and equity\n    this._balanceValue = this._host.factory.createWatchedValue(this._accountManagerData.balance);\n    this._equityValue = this._host.factory.createWatchedValue(this._accountManagerData.equity);\n    try {\n      var storedAccountId = localStorage.getItem(LAST_USED_ACCOUNT_STORAGE_KEY);\n      if (storedAccountId) {\n        this.currentAccountSelected = storedAccountId;\n      }\n    } catch (e) {\n      console.error(\"Error accessing localStorage\", e);\n    }\n    // Subscribe to updates on the user's balance and equity values in the Account Manager\n    this._amChangeDelegate.subscribe(null, function (values) {\n      _this.updateWatchedValues(values);\n    });\n  }\n  //   subscribeDOM?(symbol: string): void {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   unsubscribeDOM?(symbol: string): void {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   previewOrder?(order: PreOrder): Promise<OrderPreviewResult> {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   closeIndividualPosition?(individualPositionId: string, amount?: number): Promise<void> {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   leverageInfo?(leverageInfoParams: LeverageInfoParams): Promise<LeverageInfo> {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   setLeverage?(leverageSetParams: LeverageSetParams): Promise<LeverageSetResult> {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   previewLeverage?(leverageSetParams: LeverageSetParams): Promise<LeveragePreviewResult> {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   subscribeMarginAvailable?(symbol: string): void {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   subscribePipValue?(symbol: string): void {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   unsubscribePipValue?(symbol: string): void {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   unsubscribeMarginAvailable?(symbol: string): void {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   individualPositions?(): Promise<IndividualPosition[]> {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   formatter?(symbol: string, alignToMinMove: boolean): Promise<INumberFormatter> {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   spreadFormatter?(symbol: string): Promise<INumberFormatter> {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   quantityFormatter?(symbol: string): Promise<INumberFormatter> {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   getOrderDialogOptions?(symbol: string): Promise<OrderDialogOptions | undefined> {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   getPositionDialogOptions?(): PositionDialogOptions | undefined {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  //   getSymbolSpecificTradingOptions?(symbol: string): Promise<SymbolSpecificTradingOptions | undefined> {\n  //    throw new Error(\"Method not implemented.\");\n  //   }\n  return _createClass(BrokerSample, [{\n    key: \"ordersHistory\",\n    value: function () {\n      var _ordersHistory = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this.fetchOrderHistory();\n            case 2:\n              return _context.abrupt(\"return\", Promise.resolve(this._orderHistorylist));\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function ordersHistory() {\n        return _ordersHistory.apply(this, arguments);\n      }\n      return ordersHistory;\n    }()\n  }, {\n    key: \"fetchOrderHistory\",\n    value: function () {\n      var _fetchOrderHistory = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(loginNumber === 0)) {\n                _context2.next = 6;\n                break;\n              }\n              console.warn(\"Login number is not set. Waiting...\");\n              _context2.next = 4;\n              return new Promise(function (resolve) {\n                return setTimeout(resolve, 500);\n              });\n            case 4:\n              console.error(\"Login number is still not set after waiting\");\n              return _context2.abrupt(\"return\");\n            case 6:\n              _context2.next = 8;\n              return (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.makeApiRequest)(\"\".concat(BASE_URL, \"/api/History/get_page?login=\").concat(loginNumber, \"&offset=0&total=1000&source=tv\"));\n            case 8:\n              response = _context2.sent;\n              if (response.data) {\n                this._orderHistorylist = response.data.map(function (item) {\n                  return _objectSpread(_objectSpread({}, item), {}, {\n                    qty: item.qty / 10000,\n                    // Convert units to lots\n                    timeSetup: item.timeSetup * 1000\n                  });\n                });\n              } else {\n                console.error(\"Failed to fetch order data:\", response);\n              }\n            case 10:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function fetchOrderHistory() {\n        return _fetchOrderHistory.apply(this, arguments);\n      }\n      return fetchOrderHistory;\n    }()\n  }, {\n    key: \"handleWebSocketUpdates\",\n    value: function handleWebSocketUpdates(values) {\n      this._accountManagerData.balance = values.balance;\n      this._accountManagerData.equity = values.equity;\n      this._accountManagerData.pl = values.pl;\n      this._amChangeDelegate.fire(this._accountManagerData);\n    }\n    // Update the watched balance and equity values\n  }, {\n    key: \"updateWatchedValues\",\n    value: function updateWatchedValues(values) {\n      this._balanceValue.setValue(values.balance);\n      this._equityValue.setValue(values.equity);\n      this._plValue.setValue(values.pl);\n    }\n  }, {\n    key: \"updateAccountData\",\n    value: function updateAccountData(newTitle, newBalance, newEquity, newPl) {\n      this._accountManagerData.title = newTitle;\n      this._accountManagerData.balance = newBalance;\n      this._accountManagerData.equity = newEquity;\n      this._accountManagerData.pl = newPl;\n      this._balanceValue.setValue(newBalance);\n      this._equityValue.setValue(newEquity);\n      this._plValue.setValue(newPl);\n      this._amChangeDelegate.fire(this._accountManagerData);\n    }\n  }, {\n    key: \"getAccountData\",\n    value: function getAccountData() {\n      return this._accountManagerData;\n    }\n  }, {\n    key: \"subscribeBalanceEquityData\",\n    value: function subscribeBalanceEquityData() {\n      console.log(\"loginNumber\", loginNumber);\n      if (this._balanceEquityStreaming) {\n        this._balanceEquityStreaming.close();\n        this._balanceEquityStreaming.unsubscribe(this.handleWebSocketUpdates.bind(this));\n      }\n      // Set up the WebSocket connection to stream balance and equity\n      this._balanceEquityStreaming = new _streaming_js__WEBPACK_IMPORTED_MODULE_2__.BalanceEquityStreaming(loginNumber);\n      // Subscribe to updates from the WebSocket stream\n      this._balanceEquityStreaming.subscribe(this.handleWebSocketUpdates.bind(this));\n    }\n  }, {\n    key: \"fetchAccountManageerData\",\n    value: function fetchAccountManageerData() {\n      this.fetchAccountData();\n      this.fetchOrders();\n      this.fetchPositions();\n    }\n    // Helper function to get the current suffix\n  }, {\n    key: \"getSuffix\",\n    value: function getSuffix() {\n      return localStorage.getItem(\"suffix\") || \"\";\n    }\n    // Helper function to append the suffix\n  }, {\n    key: \"appendSuffix\",\n    value: function appendSuffix(symbol) {\n      var suffix = this.getSuffix();\n      if (suffix && symbol && !symbol.endsWith(suffix)) {\n        return symbol + suffix;\n      }\n      return symbol;\n    }\n    // Helper function to remove the suffix\n    // private removeSuffix(symbol: string): string {\n    //   const suffix = this.getSuffix();\n    //   if (suffix && symbol && symbol.endsWith(suffix)) {\n    //     return symbol.slice(0, -suffix.length);\n    //   }\n    //   return symbol;\n    // }\n  }, {\n    key: \"fetchUser\",\n    value: function () {\n      var _fetchUser = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _this2 = this;\n        var _a, data, filteredAccounts, accountToUse;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.makeCRMApiRequest)(\"\".concat(OPO_BASE_URL, \"/client-api/accounts?version=1.0.0\"));\n            case 2:\n              data = _context3.sent;\n              if (Array.isArray(data)) {\n                filteredAccounts = data.filter(function (account) {\n                  return account.type.id === 57 || account.type.id === 58 || account.type.id === 59 || account.type.id === 60 || account.type.id === 61 || account.type.id === 62 || account.type.id === 63 || account.type.id === 64 || account.type.id === 65 || account.type.id === 66 || account.type.id === 67;\n                });\n                loginNumber = parseInt(filteredAccounts[0].login);\n                this.subscribeBalanceEquityData();\n                this.fetchAccountManageerData();\n                this._accountlist = filteredAccounts.map(function (account) {\n                  var _a, _b;\n                  var suffix = (_a = BrokerSample.accountTypeIdToSuffixMap[account.type.id]) !== null && _a !== void 0 ? _a : \"\";\n                  _this2._accountSuffixes.set(account.login, suffix);\n                  return {\n                    id: account.login,\n                    name: \"\".concat(((_b = account.type) === null || _b === void 0 ? void 0 : _b.description) || \"Account\", \" \").concat(account.login)\n                  };\n                });\n                // Check if the stored account ID is among the fetched accounts\n                accountToUse = this.currentAccountSelected;\n                if (!this._accountlist.find(function (account) {\n                  return account.id === accountToUse;\n                })) {\n                  // If not found, use the first account\n                  accountToUse = (_a = this._accountlist[0]) === null || _a === void 0 ? void 0 : _a.id;\n                }\n                this.currentAccountSelected = accountToUse;\n                loginNumber = parseInt(accountToUse);\n                // Now fetch account data for the selected account\n                this.subscribeBalanceEquityData();\n                this.fetchAccountManageerData();\n                console.log(\"Filtered account logins:\", this._accountlist);\n              } else {\n                console.error(\"Unexpected response format:\", data);\n              }\n            case 4:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function fetchUser() {\n        return _fetchUser.apply(this, arguments);\n      }\n      return fetchUser;\n    }()\n  }, {\n    key: \"fetchAccountData\",\n    value: function () {\n      var _fetchAccountData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var response, data;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(loginNumber === 0)) {\n                _context4.next = 6;\n                break;\n              }\n              console.warn(\"Login number is not set. Waiting...\");\n              _context4.next = 4;\n              return new Promise(function (resolve) {\n                return setTimeout(resolve, 500);\n              });\n            case 4:\n              console.error(\"Login number is still not set after waiting\");\n              return _context4.abrupt(\"return\");\n            case 6:\n              _context4.next = 8;\n              return (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.makeApiRequest)(\"\".concat(BASE_URL, \"/api/User/get_trade_state?login=\").concat(loginNumber, \"&source=tv\"));\n            case 8:\n              response = _context4.sent;\n              if (response.data) {\n                console.log(\"fetchAccountData\", response.data);\n                data = response.data;\n                this.updateAccountData(data.title, data.balance, data.equity, data.pl);\n                this._host.currentAccountUpdate();\n              } else {\n                console.error(\"Failed to fetch account data:\", response);\n              }\n            case 10:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function fetchAccountData() {\n        return _fetchAccountData.apply(this, arguments);\n      }\n      return fetchAccountData;\n    }()\n  }, {\n    key: \"fetchPositions\",\n    value: function () {\n      var _fetchPositions = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!(loginNumber === 0)) {\n                _context5.next = 6;\n                break;\n              }\n              console.warn(\"Login number is not set. Waiting...\");\n              _context5.next = 4;\n              return new Promise(function (resolve) {\n                return setTimeout(resolve, 500);\n              });\n            case 4:\n              console.error(\"Login number is still not set after waiting\");\n              return _context5.abrupt(\"return\");\n            case 6:\n              console.log(\"fetchPositions\");\n              _context5.next = 9;\n              return (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.makeApiRequest)(\"\".concat(BASE_URL, \"/api/Position/get_page?login=\").concat(loginNumber, \"&offset=0&total=1000&source=tv\"));\n            case 9:\n              response = _context5.sent;\n              if (response.data) {\n                this._positionlist = response.data.map(function (item) {\n                  return {\n                    id: item.id.toString(),\n                    symbol: \"Opofinance:\" + item.symbol,\n                    symbolName: item.symbol,\n                    side: item.side === 1 ? 1 : -1,\n                    qty: item.qty / 10000,\n                    avgPrice: item.price,\n                    profit: item.profit,\n                    timeCreate: item.timeCreate * 1000\n                  };\n                });\n                console.log(\"fetchPositions\", this._positionlist);\n              } else {\n                console.error(\"Failed to fetch positions data:\", response);\n              }\n            case 11:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function fetchPositions() {\n        return _fetchPositions.apply(this, arguments);\n      }\n      return fetchPositions;\n    }()\n  }, {\n    key: \"fetchOrders\",\n    value: function () {\n      var _fetchOrders = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!(loginNumber === 0)) {\n                _context6.next = 6;\n                break;\n              }\n              console.warn(\"Login number is not set. Waiting...\");\n              _context6.next = 4;\n              return new Promise(function (resolve) {\n                return setTimeout(resolve, 500);\n              });\n            case 4:\n              console.error(\"Login number is still not set after waiting\");\n              return _context6.abrupt(\"return\");\n            case 6:\n              _context6.next = 8;\n              return (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.makeApiRequest)(\"\".concat(BASE_URL, \"/api/Order/get_page?login=\").concat(loginNumber, \"&offset=0&total=1000&source=tv\"));\n            case 8:\n              response = _context6.sent;\n              if (response.data) {\n                this._orderlist = response.data.map(function (item) {\n                  return _objectSpread(_objectSpread({}, item), {}, {\n                    symbol: \"Opofinance:\" + item.symbol,\n                    symbolName: item.symbol,\n                    qty: item.qty / 10000,\n                    // Convert units to lots\n                    timeSetup: item.timeSetup * 1000\n                  });\n                });\n              } else {\n                console.error(\"Failed to fetch order data:\", response);\n              }\n            case 10:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function fetchOrders() {\n        return _fetchOrders.apply(this, arguments);\n      }\n      return fetchOrders;\n    }()\n    /**\n     * Subscribes to updates of the equity value.\n     * The library calls this method when users open Order Ticket.\n     */\n  }, {\n    key: \"subscribeEquity\",\n    value: function subscribeEquity() {\n      this._equityValue.subscribe(this._handleEquityUpdate, {\n        callWithLast: true\n      });\n    }\n    /**\n     * Unsubscribes from updates of the equity value.\n     * The library calls this method when users close Order Ticket.\n     */\n  }, {\n    key: \"unsubscribeEquity\",\n    value: function unsubscribeEquity() {\n      this._equityValue.unsubscribe(this._handleEquityUpdate);\n    }\n    /**\n     * Defines the connection status for the Broker API.\n     * If any other value than `1` (\"Connected\") is returned, the Account Manager will display an endless spinner.\n     */\n  }, {\n    key: \"connectionStatus\",\n    value: function connectionStatus() {\n      return 1 /* ConnectionStatus.Connected */;\n    }\n    /**\n     * Returns an array of `ActionMetaInfo` elements by calling the `defaultContextMenuActions` method of the Trading Host.\n     * Each `ActionMetaInfo` element represents one context menu item.\n     *\n     * The library calls `chartContextMenuActions` when users open the context menu on the chart.\n     * This method also renders the \"Trade\" button in the context menu.\n     */\n  }, {\n    key: \"chartContextMenuActions\",\n    value: function chartContextMenuActions(context, options) {\n      return this._host.defaultContextMenuActions(context);\n    }\n    /**\n     * Checks if a symbol can be traded.\n     * In this sample, `isTradable` is a mock function that always returns `true`, meaning that all symbols can be traded.\n     */\n  }, {\n    key: \"isTradable\",\n    value: function isTradable(symbol) {\n      return Promise.resolve(true);\n    }\n    // Map TradingView OrderType to your API action and type\n  }, {\n    key: \"mapOrderTypeToActionAndType\",\n    value: function mapOrderTypeToActionAndType(orderType, side) {\n      var action = \"\";\n      var type = 0;\n      if (orderType === 2 /* OrderType.Market */) {\n        action = \"200\";\n        type = side === 1 ? 0 : 1; // 0 for Buy Market, 1 for Sell Market\n      } else if (orderType === 1 /* OrderType.Limit */) {\n        action = \"201\";\n        type = side === 1 ? 2 : 3; // 2 for Buy Limit, 3 for Sell Limit\n      } else if (orderType === 3 /* OrderType.Stop */) {\n        action = \"201\";\n        type = side === 1 ? 4 : 5; // 4 for Buy Stop, 5 for Sell Stop\n      } else {\n        throw new Error(\"Unsupported order type\");\n      }\n      return {\n        action: action,\n        type: type\n      };\n    }\n    // Places an order and returns an object with the order ID.\n    // The library calls this method when users place orders in the UI.\n  }, {\n    key: \"placeOrder\",\n    value: function () {\n      var _placeOrder = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(preOrder) {\n        var _this3 = this;\n        var symbolWithSuffix, _this$mapOrderTypeToA, action, type, digits, payload, price, response, responseData, orderId, result, orders, position, errorMessage;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              console.log(\"placeOrder\", preOrder);\n              symbolWithSuffix = this.appendSuffix(preOrder.symbol);\n              _context7.prev = 2;\n              // Map the order type and side to your API parameters\n              _this$mapOrderTypeToA = this.mapOrderTypeToActionAndType(preOrder.type, preOrder.side), action = _this$mapOrderTypeToA.action, type = _this$mapOrderTypeToA.type; // Validate required fields\n              if (!(!preOrder.symbol || !preOrder.qty)) {\n                _context7.next = 6;\n                break;\n              }\n              throw new Error(\"Symbol and quantity are required\");\n            case 6:\n              digits = this._symbolDigits[preOrder.symbol]; // Construct the payload\n              payload = {\n                action: action,\n                login: Number(this.currentAccountSelected),\n                symbol: symbolWithSuffix.includes(\":\") ? symbolWithSuffix.split(\":\")[1] : symbolWithSuffix,\n                volume: preOrder.qty * 10000,\n                typeFill: preOrder.type === 2 /* OrderType.Market */ ? 0 : 2,\n                // 0 for Market, 2 for Pending Orders\n                type: type,\n                digits: digits,\n                source: \"tv\",\n                position: preOrder.positionId,\n                priceTrigger: 0\n              }; // For pending orders, add additional fields\n              if (!(preOrder.type === 1 /* OrderType.Limit */ || preOrder.type === 3 /* OrderType.Stop */)) {\n                _context7.next = 14;\n                break;\n              }\n              // Ensure price is provided\n              price = preOrder.limitPrice || preOrder.stopPrice;\n              if (price) {\n                _context7.next = 12;\n                break;\n              }\n              throw new Error(\"Price is required for limit and stop orders\");\n            case 12:\n              payload.priceOrder = price;\n              // payload.digits = 5; // Adjust as necessary\n              payload.typetime = 0; // As per your API requirements\n            case 14:\n              //for bracket orders\n              if (preOrder.takeProfit !== undefined || preOrder.stopLoss !== undefined) {\n                payload.priceSL = preOrder.stopLoss || 0;\n                payload.priceTP = preOrder.takeProfit || 0;\n              }\n              // Send the request to your API\n              _context7.next = 17;\n              return this.sendRequest(payload);\n            case 17:\n              response = _context7.sent;\n              if (!(response && response.success)) {\n                _context7.next = 26;\n                break;\n              }\n              responseData = response.data;\n              orderId = responseData.id.toString(); // Create an order object to represent the new order\n              result = {\n                id: orderId,\n                symbol: responseData.symbol,\n                side: preOrder.side,\n                qty: responseData.qty / 10000,\n                type: responseData.type,\n                filledQty: responseData.filledQty / 10000,\n                avgPrice: responseData.avgPrice,\n                limitPrice: responseData.limitPrice,\n                stopPrice: responseData.stopPrice,\n                status: responseData.status === 2 ? 6 /* OrderStatus.Working */ : 5 /* OrderStatus.Rejected */,\n\n                // status: (responseData.status === 5 || responseData.status === 2 ? 2 : responseData.status),\n                stopLoss: responseData.stopLoss,\n                takeProfit: responseData.takeProfit\n                // parentId: preOrder.positionId,\n                // Include any additional fields from responseData as needed\n              }; // Update internal order storage\n\n              if (preOrder.takeProfit !== undefined || preOrder.stopLoss !== undefined) {\n                orders = this._createOrderWithBrackets(responseData);\n                orders.forEach(function (order) {\n                  _this3._updateOrder(order);\n                });\n              } else {\n                if (preOrder.positionId) {\n                  position = _objectSpread(_objectSpread({}, result), {}, {\n                    id: preOrder.positionId.toString(),\n                    qty: 0,\n                    status: 2 /* OrderStatus.Filled */\n                  });\n                  this._updatePosition(position);\n                } else {\n                  this._updateOrder(_objectSpread({}, result));\n                }\n              }\n              return _context7.abrupt(\"return\", {\n                orderId: orderId\n              });\n            case 26:\n              // Handle errors\n              errorMessage = response ? response.message : \"Unknown error\";\n              console.error(\"Failed to place order:\", errorMessage);\n              return _context7.abrupt(\"return\", Promise.reject(new Error(errorMessage)));\n            case 29:\n              _context7.next = 35;\n              break;\n            case 31:\n              _context7.prev = 31;\n              _context7.t0 = _context7[\"catch\"](2);\n              console.error(\"Error in placeOrder:\", _context7.t0);\n              return _context7.abrupt(\"return\", Promise.reject(_context7.t0));\n            case 35:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[2, 31]]);\n      }));\n      function placeOrder(_x) {\n        return _placeOrder.apply(this, arguments);\n      }\n      return placeOrder;\n    }()\n    /**\n     * Modifies an existing order.\n     * The library calls this method when a user wants to modify an existing order.\n     */\n  }, {\n    key: \"modifyOrder\",\n    value: (function () {\n      var _modifyOrder = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(order) {\n        var symbolWithSuffix, originalOrder, body, response, responseData, modifiedOrder, errorMessage, takeProfitBracket, stopLossBracket;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              symbolWithSuffix = this.appendSuffix(order.symbol); // Retrieve the order from `_orderById` map\n              originalOrder = this._orderById[order.id];\n              if (!(originalOrder === undefined)) {\n                _context8.next = 5;\n                break;\n              }\n              console.error(\"Original order not found:\", order.id);\n              return _context8.abrupt(\"return\");\n            case 5:\n              _context8.prev = 5;\n              //  // Map the order type and side to your API parameters\n              //  const { action } = this.mapOrderTypeToActionAndType(\n              //   order.type,\n              //   order.side\n              // );\n              body = {\n                action: \"203\",\n                order: parseInt(order.id),\n                externalID: \"\",\n                login: this.currentAccountSelected,\n                symbol: symbolWithSuffix.includes(\":\") ? symbolWithSuffix.split(\":\")[1] : symbolWithSuffix,\n                priceOrder: order.limitPrice,\n                priceSL: order.stopLoss === undefined ? 0 : order.stopLoss,\n                priceTP: order.takeProfit === undefined ? 0 : order.takeProfit,\n                volumeInitial: order.qty * 10000,\n                digits: 5\n              };\n              _context8.next = 9;\n              return this.modifyOrderApi(body);\n            case 9:\n              response = _context8.sent;\n              if (!(response && response.success)) {\n                _context8.next = 17;\n                break;\n              }\n              // Create an order object to represent the new order\n              responseData = response.data;\n              modifiedOrder = {\n                id: responseData.order.toString(),\n                symbol: order.symbol.includes(\":\") ? order.symbol.split(\":\")[1] : order.symbol,\n                side: order.side,\n                qty: responseData.volumeInitial / 10000,\n                type: order.type,\n                limitPrice: order.limitPrice,\n                stopPrice: order.stopPrice,\n                avgPrice: responseData.last,\n                status: responseData.order === \"0\" ? 5 /* OrderStatus.Rejected */ : 6 /* OrderStatus.Working */ // Adjust based on your API's response\n                // Include any additional fields from responseData as needed\n              }; // Update internal order storage\n\n              this._orderById[order.id] = _objectSpread(_objectSpread({}, modifiedOrder), {}, {\n                symbolName: modifiedOrder.symbol\n              });\n              this._host.orderUpdate(_objectSpread(_objectSpread({}, modifiedOrder), {}, {\n                symbolName: modifiedOrder.symbol\n              }));\n              _context8.next = 20;\n              break;\n            case 17:\n              // Handle errors\n              errorMessage = response ? response.message : \"Unknown error\";\n              console.error(\"Failed to place order:\", errorMessage);\n              return _context8.abrupt(\"return\", Promise.reject(new Error(errorMessage)));\n            case 20:\n              _context8.next = 26;\n              break;\n            case 22:\n              _context8.prev = 22;\n              _context8.t0 = _context8[\"catch\"](5);\n              console.error(\"API error modifying order:\", _context8.t0);\n              return _context8.abrupt(\"return\", Promise.reject(new Error(_context8.t0.message)));\n            case 26:\n              if (!(order.parentId !== undefined)) {\n                _context8.next = 28;\n                break;\n              }\n              return _context8.abrupt(\"return\");\n            case 28:\n              // Get the take-profit and stop-loss brackets associated with this order\n              takeProfitBracket = this._getTakeProfitBracket(order);\n              stopLossBracket = this._getStopLossBracket(order); // Update the object of the take-profit bracket order\n              this._updateOrdersBracket({\n                parent: order,\n                bracket: takeProfitBracket,\n                newPrice: order.takeProfit,\n                bracketType: 1 /* BracketType.TakeProfit */\n              });\n              // Update the object of the stop-loss bracket order\n              this._updateOrdersBracket({\n                parent: order,\n                bracket: stopLossBracket,\n                newPrice: order.stopLoss,\n                bracketType: 0 /* BracketType.StopLoss */\n              });\n            case 32:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[5, 22]]);\n      }));\n      function modifyOrder(_x2) {\n        return _modifyOrder.apply(this, arguments);\n      }\n      return modifyOrder;\n    }() /** Helper method for calling the broker's API to modify the order */)\n  }, {\n    key: \"modifyOrderApi\",\n    value: (function () {\n      var _modifyOrderApi = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(body) {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.prev = 0;\n              _context9.next = 3;\n              return (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.makePostApiRequest)(\"\".concat(BASE_URL, \"/api/Order/update_order\"), body);\n            case 3:\n              response = _context9.sent;\n              return _context9.abrupt(\"return\", response);\n            case 7:\n              _context9.prev = 7;\n              _context9.t0 = _context9[\"catch\"](0);\n              throw new Error(\"Failed to modify order: \" + _context9.t0.message);\n            case 10:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, null, [[0, 7]]);\n      }));\n      function modifyOrderApi(_x3) {\n        return _modifyOrderApi.apply(this, arguments);\n      }\n      return modifyOrderApi;\n    }())\n  }, {\n    key: \"editIndividualPositionBrackets\",\n    value: function editIndividualPositionBrackets(positionId, modifiedBrackets) {\n      console.log(\"placeOrder editIndividualPositionBrackets\", positionId, modifiedBrackets);\n      return Promise.resolve();\n    }\n    /**\n     * Enables a dialog that allows adding bracket orders to a position.\n     * The library calls this method when users modify existing position with bracket orders.\n     */\n  }, {\n    key: \"editPositionBrackets\",\n    value: (function () {\n      var _editPositionBrackets = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(positionId, modifiedBrackets) {\n        var _a, _b, position, positionBrackets, modifiedPosition, symbolWithSuffix, body, response, result, errorMessage, takeProfitBracket, stopLossBracket;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              console.log(\"placeOrder editPositionBrackets\", positionId, modifiedBrackets);\n              // Retrieve the position object using its ID\n              position = this._positionById[positionId]; // Retrieve all brackets associated with this position\n              positionBrackets = this._getBrackets(positionId); // Create a modified position object based on the original position\n              modifiedPosition = _objectSpread({}, position);\n              symbolWithSuffix = this.appendSuffix(modifiedPosition.symbol); // Add this line\n              // Map the order type and side to your API parameters\n              //  const { action } = this.mapOrderTypeToActionAndType(\n              //   modifiedPosition.type,\n              //   modifiedPosition.side\n              // );\n              body = {\n                action: \"203\",\n                position: parseInt(positionId),\n                externalID: \"\",\n                login: loginNumber,\n                symbol: symbolWithSuffix.split(\":\")[1],\n                // priceOrder: modifiedPosition.seenPrice,\n                priceSL: modifiedBrackets.stopLoss === undefined ? 0 : modifiedBrackets.stopLoss,\n                priceTP: modifiedBrackets.takeProfit === undefined ? 0 : modifiedBrackets.takeProfit,\n                volumeInitial: modifiedPosition.qty * 10000,\n                digits: 5\n              };\n              _context10.next = 8;\n              return this.editPositionsApi(body);\n            case 8:\n              response = _context10.sent;\n              console.log(\"placeOrder edit data\", response.data);\n              result = response.data;\n              if (!(response && response.success)) {\n                _context10.next = 21;\n                break;\n              }\n              (_a = modifiedPosition.takeProfit) !== null && _a !== void 0 ? _a : modifiedPosition.takeProfit = modifiedBrackets.takeProfit;\n              (_b = modifiedPosition.stopLoss) !== null && _b !== void 0 ? _b : modifiedPosition.stopLoss = modifiedBrackets.stopLoss;\n              modifiedPosition.symbol = symbolWithSuffix.split(\":\")[1];\n              modifiedPosition.qty = result.volumeInitial / 10000;\n              modifiedPosition.symbolName = result.symbol;\n              console.log(\"modifiedPosition\", modifiedPosition);\n              this._updatePosition(_objectSpread({}, modifiedPosition));\n              _context10.next = 24;\n              break;\n            case 21:\n              // Handle errors\n              errorMessage = response ? response.message : \"Unknown error\";\n              console.error(\"Failed to place order:\", errorMessage);\n              return _context10.abrupt(\"return\", Promise.reject(new Error(errorMessage)));\n            case 24:\n              // Update take-profit and stop-loss prices in the modified position object if they are provided\n              // Find the take-profit and stop-loss brackets from the position's brackets\n              takeProfitBracket = positionBrackets.find(function (bracket) {\n                return bracket.limitPrice !== undefined;\n              });\n              stopLossBracket = positionBrackets.find(function (bracket) {\n                return bracket.stopPrice !== undefined;\n              }); // Update the object of the take-profit bracket order\n              this._updatePositionsBracket({\n                parent: modifiedPosition,\n                bracket: takeProfitBracket,\n                bracketType: 1 /* BracketType.TakeProfit */,\n                newPrice: modifiedBrackets.takeProfit\n              });\n              // Update the object of the stop-loss bracket order\n              this._updatePositionsBracket({\n                parent: modifiedPosition,\n                bracket: stopLossBracket,\n                bracketType: 0 /* BracketType.StopLoss */,\n                newPrice: modifiedBrackets.stopLoss\n              });\n            case 28:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function editPositionBrackets(_x4, _x5) {\n        return _editPositionBrackets.apply(this, arguments);\n      }\n      return editPositionBrackets;\n    }())\n  }, {\n    key: \"editPositionsApi\",\n    value: function () {\n      var _editPositionsApi = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(body) {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              _context11.prev = 0;\n              _context11.next = 3;\n              return (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.makePostApiRequest)(\"\".concat(BASE_URL, \"/api/Position/update_position\"), body);\n            case 3:\n              response = _context11.sent;\n              return _context11.abrupt(\"return\", response);\n            case 7:\n              _context11.prev = 7;\n              _context11.t0 = _context11[\"catch\"](0);\n              throw new Error(\"Failed to edit position: \" + _context11.t0.message);\n            case 10:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, null, [[0, 7]]);\n      }));\n      function editPositionsApi(_x6) {\n        return _editPositionsApi.apply(this, arguments);\n      }\n      return editPositionsApi;\n    }() /** Closes a position by the specified ID */\n  }, {\n    key: \"closePosition\",\n    value: (function () {\n      var _closePosition = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(positionId) {\n        var _this4 = this;\n        var position, symbolWithSuffix, handler;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              position = this._positionById[positionId];\n              symbolWithSuffix = this.appendSuffix(position.symbol); // Check if the position exists\n              if (position) {\n                _context12.next = 4;\n                break;\n              }\n              return _context12.abrupt(\"return\", Promise.reject(new Error(\"Position not found\")));\n            case 4:\n              // Place the close order\n              // const positionOrder: any = {\n              //   symbol: position.symbol,\n              //   side: position.side === Side.Sell ? Side.Buy : Side.Sell,\n              //   type: OrderType.Market,\n              //   qty: position.qty,\n              //   positionId: parseInt(positionId),\n              // };\n              // const orderId = await this.placeOrder(positionOrder);\n              // console.log(\"closePosition\", orderId);\n              handler = function handler() {\n                _this4.placeOrder({\n                  symbol: symbolWithSuffix,\n                  side: position.side === -1 /* Side.Sell */ ? 1 /* Side.Buy */ : -1 /* Side.Sell */,\n                  type: 2 /* OrderType.Market */,\n                  qty: position.qty,\n                  positionId: parseInt(positionId)\n                });\n              };\n              _context12.next = 7;\n              return handler();\n            case 7:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function closePosition(_x7) {\n        return _closePosition.apply(this, arguments);\n      }\n      return closePosition;\n    }() /** Returns users's active orders */)\n  }, {\n    key: \"orders\",\n    value: (function () {\n      var _orders2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              if (!this.currentAccountSelected) {\n                _context13.next = 3;\n                break;\n              }\n              _context13.next = 3;\n              return this.fetchOrders();\n            case 3:\n              return _context13.abrupt(\"return\", this._orders());\n            case 4:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function orders() {\n        return _orders2.apply(this, arguments);\n      }\n      return orders;\n    }() /** Returns user's positions */)\n  }, {\n    key: \"positions\",\n    value: (function () {\n      var _positions = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var _this5 = this;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              if (!this.currentAccountSelected) {\n                _context14.next = 3;\n                break;\n              }\n              _context14.next = 3;\n              return this.fetchPositions();\n            case 3:\n              if (this._positionlist.length > 0) {\n                this._positionlist.forEach(function (position) {\n                  // this._positionById[position.id] = position;\n                  // Check if this position is new or updated before processing\n                  var existingPosition = _this5._positionById[position.id];\n                  // If position does not exist or is updated, call _updatePosition()\n                  if (!existingPosition || existingPosition.qty !== position.qty || existingPosition.price !== position.price) {\n                    _this5._updatePosition(position);\n                    console.log(\"position\", position);\n                  }\n                });\n              }\n              return _context14.abrupt(\"return\", Promise.resolve(this._positionlist.slice()));\n            case 5:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function positions() {\n        return _positions.apply(this, arguments);\n      }\n      return positions;\n    }() /** Returns executions for the specified symbol */)\n  }, {\n    key: \"executions\",\n    value: function executions(symbol) {\n      return Promise.resolve(this._executions.filter(function (data) {\n        return data.symbol === symbol;\n      }));\n    }\n    /** Reverses the side of a position */\n  }, {\n    key: \"reversePosition\",\n    value: (function () {\n      var _reversePosition = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(positionId) {\n        var _this6 = this;\n        var position, handler;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              position = this._positionById[positionId];\n              handler = function handler() {\n                return _this6.placeOrder({\n                  symbol: position.symbol,\n                  side: position.side === -1 /* Side.Sell */ ? 1 /* Side.Buy */ : -1 /* Side.Sell */,\n                  type: 2 /* OrderType.Market */,\n                  qty: position.qty * 2\n                });\n              };\n              _context15.next = 4;\n              return handler();\n            case 4:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this);\n      }));\n      function reversePosition(_x8) {\n        return _reversePosition.apply(this, arguments);\n      }\n      return reversePosition;\n    }() /** Cancels a single order with a given ID */)\n  }, {\n    key: \"cancelOrder\",\n    value: function cancelOrder(orderId) {\n      var _this7 = this;\n      var order = this._orderById[orderId];\n      // Check if the order exists\n      if (!order) {\n        console.error(\"Order not found for cancellation:\", orderId);\n        return Promise.reject(new Error(\"Order not found\"));\n      }\n      // Define a function that will cancel the order and its brackets\n      var handler = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n          var response;\n          return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n            while (1) switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.prev = 0;\n                // Update the order status to \"Placing\" while the API call is being made\n                order.status = 4 /* OrderStatus.Placing */;\n                _this7._updateOrder(order);\n                // Make API call to broker to cancel the order\n                _context16.next = 5;\n                return _this7.cancelOrderApi(orderId);\n              case 5:\n                response = _context16.sent;\n                if (!response.success) {\n                  _context16.next = 12;\n                  break;\n                }\n                // Update the order status to Canceled in TradingView\n                order.status = 1 /* OrderStatus.Canceled */;\n                order.id = orderId.toString();\n                _this7._updateOrder(order);\n                // return Promise.resolve();\n                _context16.next = 16;\n                break;\n              case 12:\n                // Handle broker's API failure response\n                console.error(\"Failed to cancel order:\", response.message);\n                order.status = 5 /* OrderStatus.Rejected */;\n                _this7._updateOrder(order);\n                return _context16.abrupt(\"return\", Promise.reject(new Error(response.message)));\n              case 16:\n                _context16.next = 24;\n                break;\n              case 18:\n                _context16.prev = 18;\n                _context16.t0 = _context16[\"catch\"](0);\n                // Handle any errors from the API call itself\n                console.error(\"Error canceling order via API:\", _context16.t0);\n                order.status = 5 /* OrderStatus.Rejected */;\n                _this7._updateOrder(order);\n                return _context16.abrupt(\"return\", Promise.reject(new Error(_context16.t0.message)));\n              case 24:\n              case \"end\":\n                return _context16.stop();\n            }\n          }, _callee16, null, [[0, 18]]);\n        }));\n        return function handler() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      // Cancel associated bracket orders if any exist\n      this._getBrackets(order.id).forEach(function (bracket) {\n        _this7.cancelOrder(bracket.id);\n      });\n      return handler();\n    }\n    /** Helper method for calling the broker's API to cancel the order */\n  }, {\n    key: \"cancelOrderApi\",\n    value: (function () {\n      var _cancelOrderApi = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(orderId) {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              _context17.prev = 0;\n              _context17.next = 3;\n              return (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.makeApiRequest)(\"\".concat(BASE_URL, \"/api/Order/cancel?ticket=\").concat(orderId));\n            case 3:\n              response = _context17.sent;\n              return _context17.abrupt(\"return\", response);\n            case 7:\n              _context17.prev = 7;\n              _context17.t0 = _context17[\"catch\"](0);\n              throw new Error(\"Failed to cancel order: \" + _context17.t0.message);\n            case 10:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, null, [[0, 7]]);\n      }));\n      function cancelOrderApi(_x9) {\n        return _cancelOrderApi.apply(this, arguments);\n      }\n      return cancelOrderApi;\n    }() /** Cancels multiple orders for a symbol and side */)\n  }, {\n    key: \"cancelOrders\",\n    value: function cancelOrders(symbol, side, ordersIds) {\n      var _this8 = this;\n      var closeHandler = function closeHandler() {\n        return Promise.all(ordersIds.map(function (orderId) {\n          return _this8.cancelOrder(orderId);\n        })).then(function () {}); // tslint:disable-line:no-empty\n      };\n      return closeHandler();\n    }\n    /** Builds the Account Manager that displays trading information */\n  }, {\n    key: \"accountManagerInfo\",\n    value: function accountManagerInfo() {\n      var _this9 = this;\n      // Data object for the \"Account Summary\" row\n      var summaryProps = [{\n        text: \"Balance\",\n        wValue: this._balanceValue,\n        formatter: \"fixed\" /* StandardFormatterName.Fixed */,\n        // Default value\n        isDefault: true\n      }, {\n        text: \"Equity\",\n        wValue: this._equityValue,\n        formatter: \"fixed\" /* StandardFormatterName.Fixed */,\n        // Default value\n        isDefault: true\n      }, {\n        text: \"P/L\",\n        wValue: this._plValue,\n        formatter: \"profit\" /* StandardFormatterName.Profit */,\n        isDefault: true\n      }];\n      return {\n        accountTitle: \"OPO Trade\",\n        // Custom fields that are displayed in the \"Account Summary\" row\n        summary: summaryProps,\n        // Columns that build the \"Orders\" page\n        orderColumns: _columns_js__WEBPACK_IMPORTED_MODULE_0__.ordersPageColumns,\n        // Columns that build the \"Positions\" page\n        positionColumns: _columns_js__WEBPACK_IMPORTED_MODULE_0__.positionsPageColumns,\n        // Columns that build the custom \"Account Summary\" page\n        historyColumns: _columns_js__WEBPACK_IMPORTED_MODULE_0__.historyPageColumns,\n        // Columns that build the custom \"History\" page\n        pages: [{\n          id: \"accountsummary\",\n          title: \"Account Summary\",\n          tables: [{\n            id: \"accountsummary\",\n            columns: _columns_js__WEBPACK_IMPORTED_MODULE_0__.accountSummaryColumns,\n            getData: function getData() {\n              return Promise.resolve([_this9._accountManagerData]);\n            },\n            initialSorting: {\n              property: \"balance\",\n              asc: false\n            },\n            changeDelegate: this._amChangeDelegate\n          }]\n        }],\n        // Function to create a custom context menu in the Account Manager\n        contextMenuActions: function contextMenuActions(contextMenuEvent, activePageActions) {\n          return Promise.resolve(_this9._bottomContextMenuItems(activePageActions));\n        }\n      };\n    }\n    /**\n     * Returns symbol information.\n     * The library calls this method when users open the Order Ticket or DOM panel.\n     */\n  }, {\n    key: \"symbolInfo\",\n    value: (function () {\n      var _symbolInfo = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18(symbol) {\n        var mintick, pipSize, accountCurrencyRate, pointValue;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              _context18.next = 2;\n              return this._host.getSymbolMinTick(symbol);\n            case 2:\n              mintick = _context18.sent;\n              pipSize = mintick; // Pip size can differ from minTick\n              accountCurrencyRate = 1; // Account currency rate\n              pointValue = 1; // USD value of 1 point of price\n              return _context18.abrupt(\"return\", {\n                qty: {\n                  min: 0.01,\n                  max: 50,\n                  step: 0.01\n                },\n                pipValue: pipSize * pointValue * accountCurrencyRate || 1,\n                pipSize: pipSize,\n                minTick: mintick,\n                description: \"\",\n                units: \"Lots\"\n              });\n            case 7:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this);\n      }));\n      function symbolInfo(_x10) {\n        return _symbolInfo.apply(this, arguments);\n      }\n      return symbolInfo;\n    }() /** Represents a mock function for a current account by returning an account ID '1' */)\n  }, {\n    key: \"currentAccount\",\n    value: function currentAccount() {\n      var _a;\n      if (this.currentAccountSelected === undefined) {\n        this.currentAccountSelected = (_a = this._accountlist[0]) === null || _a === void 0 ? void 0 : _a.id;\n      }\n      return this.currentAccountSelected;\n    }\n    /** Represents a mock function and returns information about the account with an ID '1' */\n  }, {\n    key: \"accountsMetainfo\",\n    value: (function () {\n      var _accountsMetainfo = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n        var _a;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              console.log(\"sequence accountsMetainfo\");\n              if (!(this._accountlist.length === 0)) {\n                _context19.next = 4;\n                break;\n              }\n              _context19.next = 4;\n              return this.fetchUser();\n            case 4:\n              if (this.currentAccountSelected == undefined) {\n                this.currentAccountSelected = (_a = this._accountlist[0]) === null || _a === void 0 ? void 0 : _a.id;\n              }\n              return _context19.abrupt(\"return\", _toConsumableArray(this._accountlist));\n            case 6:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this);\n      }));\n      function accountsMetainfo() {\n        return _accountsMetainfo.apply(this, arguments);\n      }\n      return accountsMetainfo;\n    }())\n  }, {\n    key: \"setCurrentAccount\",\n    value: function setCurrentAccount(id) {\n      this.currentAccountSelected = id;\n      loginNumber = parseInt(id);\n      this.fetchAccountData();\n      //close socket connection & reinitialize with new loginNumber\n      this.restartSocketForGetSelectedAccount();\n      this._host.currentAccountUpdate();\n      var suffix = this._accountSuffixes.get(id) || \"\";\n      try {\n        localStorage.setItem(\"suffix\", suffix);\n      } catch (e) {\n        console.error(\"Error accessing localStorage\", e);\n      }\n      try {\n        localStorage.setItem(LAST_USED_ACCOUNT_STORAGE_KEY, id);\n      } catch (e) {\n        console.error(\"Error accessing localStorage\", e);\n      }\n    }\n  }, {\n    key: \"restartSocketForGetSelectedAccount\",\n    value: function restartSocketForGetSelectedAccount() {\n      this._balanceEquityStreaming.close();\n      this._balanceEquityStreaming.unsubscribe(this.handleWebSocketUpdates.bind(this));\n      this._balanceEquityStreaming = new _streaming_js__WEBPACK_IMPORTED_MODULE_2__.BalanceEquityStreaming(loginNumber);\n      this._balanceEquityStreaming.subscribe(this.handleWebSocketUpdates.bind(this));\n    }\n    /** Creates custom items in the Account Manager context menu */\n  }, {\n    key: \"_bottomContextMenuItems\",\n    value: function _bottomContextMenuItems(activePageActions) {\n      var _this10 = this;\n      var separator = {\n        separator: true\n      };\n      var sellBuyButtonsVisibility = this._host.sellBuyButtonsVisibility();\n      if (activePageActions.length) {\n        activePageActions.push(separator);\n      }\n      return activePageActions.concat([\n      // Create button that modifies the visibility of the \"Sell\" and \"Buy\" buttons\n      {\n        text: \"Show Buy/Sell Buttons\",\n        action: function action() {\n          if (sellBuyButtonsVisibility) {\n            sellBuyButtonsVisibility.setValue(!sellBuyButtonsVisibility.value());\n          }\n        },\n        checkable: true,\n        checked: sellBuyButtonsVisibility !== null && sellBuyButtonsVisibility.value()\n      },\n      // Create button that opens \"Chart settings → Trading\" dialog\n      {\n        text: \"Trading Settings...\",\n        action: function action() {\n          _this10._host.showTradingProperties();\n        }\n      }]);\n    }\n    /** Creates a position for a particular order and returns a position data object */\n  }, {\n    key: \"_createPositionForOrder\",\n    value: function _createPositionForOrder(order) {\n      var _this11 = this;\n      // Create the position ID from the order's symbol\n      var positionId = order.symbol;\n      // Retrieve existing position object by ID if it exists\n      var position = this._positionById[positionId];\n      // Extract order side and quantity\n      var orderSide = order.side;\n      var orderQty = order.qty;\n      // Check whether the order is a bracket order\n      var isPositionClosedByBracket = order.parentId !== undefined;\n      order.avgPrice = order.price;\n      // Update the position object if it already exists, otherwise create a new one\n      if (position) {\n        // Compare new order and existing position sides\n        var sign = order.side === position.side ? 1 : -1;\n        // Calculate average price based on the order and position sides: \"Buy\" or \"Sell\"\n        if (sign > 0) {\n          position.avgPrice = (position.qty * position.avgPrice + order.qty * order.price) / (position.qty + order.qty);\n        } else {\n          position.avgPrice = position.avgPrice;\n          var amountToClose = Math.min(orderQty, position.qty);\n          this._accountManagerData.balance += (order.price - position.avgPrice) * amountToClose * (position.side === -1 /* Side.Sell */ ? -1 : 1);\n        }\n        // Recalculate position quantity\n        position.qty = position.qty + order.qty * sign;\n        // Get an array of bracket orders associated with the position ID\n        var brackets = this._getBrackets(position.id);\n        // Check the position quantity: whether it is closed\n        if (position.qty <= 0) {\n          brackets.forEach(function (bracket) {\n            // If the executed order is a bracket order, set its status to \"Filled\"\n            if (isPositionClosedByBracket) {\n              _this11._setFilledStatusAndUpdate(bracket);\n              return;\n            }\n            // For other orders, set their status to \"Canceled\"\n            _this11._setCanceledStatusAndUpdate(bracket);\n          });\n          // Change position side and reverse the quantity sign from negative to positive\n          position.side = changeSide(position.side);\n          position.qty *= -1;\n        } else {\n          /*\n                            If the position quantity is positive (which indicates the position is open),\n                            go through brackets and update their side and quantity to match the position's side and quantity.\n                            */\n          brackets.forEach(function (bracket) {\n            bracket.side = changeSide(position.side);\n            bracket.qty = position.qty;\n            _this11._updateOrder(bracket);\n          });\n        }\n      } else {\n        // Create a new position object if it doesn't exist\n        position = _objectSpread(_objectSpread({}, order), {}, {\n          id: positionId,\n          avgPrice: order.price\n        });\n      }\n      // Create execution object for executed order\n      var execution = {\n        id: \"\".concat(this._idsCounter++),\n        brokerSymbol: order.brokerSymbol,\n        price: order.price,\n        qty: orderQty,\n        side: orderSide,\n        symbol: order.symbol,\n        time: Date.now()\n      };\n      // Update executions list and notify the library about execution update\n      this._executions.push(execution);\n      this._host.executionUpdate(execution);\n      // Update position and Account Manager data\n      this._updatePosition(position);\n      // this._recalculateAMData();\n      // Notify the library about \"Profit and loss\" updates\n      this._host.plUpdate(position.symbol, position.profit);\n      this._host.positionPartialUpdate(position.id, position);\n      // Recalculate values in the Account Manager\n      // this._recalculateAMData();\n      return position;\n    }\n    /**\n     * Updates order objects by calling the `orderPartialUpdate` method of the Trading Host.\n     * `orderPartialUpdate` is used if the Account Manager has custom columns.\n     * In this example, the Account Manager has the custom column called \"Last\".\n     */\n  }, {\n    key: \"_updateOrderLast\",\n    value: function _updateOrderLast(order) {\n      this._host.orderPartialUpdate(order.id, {\n        last: order.last\n      });\n    }\n    /** Retrieves all orders stored in the `_orderById` map and returns an array containing all orders */\n  }, {\n    key: \"_orders\",\n    value: function _orders() {\n      var _this12 = this;\n      //  Object.values(this._orderById);\n      if (this._orderlist.length > 0) {\n        this._orderlist.forEach(function (order) {\n          // this._orderById[order.id] = order;\n          // Check if this order is new or updated before processing\n          var existingOrder = _this12._orderById[order.id];\n          // If the order does not exist or has been modified, call _updateOrder()\n          if (!existingOrder || existingOrder.qty !== order.qty || existingOrder.price !== order.price) {\n            _this12._updateOrder(order);\n            console.log(\"orders\", order);\n          }\n        });\n      }\n      return Object.values(this._orderById);\n    }\n  }, {\n    key: \"sendRequest\",\n    value: function () {\n      var _sendRequest = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20(body) {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              _context20.prev = 0;\n              _context20.next = 3;\n              return (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.makePostApiRequest)(\"\".concat(BASE_URL, \"/api/Trade/send_request\"), body);\n            case 3:\n              response = _context20.sent;\n              return _context20.abrupt(\"return\", response);\n            case 7:\n              _context20.prev = 7;\n              _context20.t0 = _context20[\"catch\"](0);\n              console.error(\"[sendRequest]:  error=\", _context20.t0);\n            case 10:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, null, [[0, 7]]);\n      }));\n      function sendRequest(_x11) {\n        return _sendRequest.apply(this, arguments);\n      }\n      return sendRequest;\n    }()\n  }, {\n    key: \"_updateOrder\",\n    value: function _updateOrder(order) {\n      console.log(\"placeOrder _updateOrder\", order);\n      var hasOrderAlready = Boolean(this._orderById[order.id]);\n      this._orderById[order.id] = _objectSpread(_objectSpread({}, order), {}, {\n        symbolName: this.getSymbolName(order.symbol)\n      });\n      if (!hasOrderAlready) {\n        this._activeSymbols.add(order.symbol);\n        this._ensureRealtimeSubscription(order.symbol);\n      }\n      this._host.orderUpdate(_objectSpread(_objectSpread({}, order), {}, {\n        symbolName: this.getSymbolName(order.symbol)\n      }));\n      if (order.parentId !== undefined) {\n        var entity = order.parentType === 2 /* ParentType.Position */ ? this._positionById[order.parentId] : this._orderById[order.parentId];\n        if (entity === undefined) {\n          return;\n        }\n        if (order.limitPrice !== undefined) {\n          entity.takeProfit = order.status !== 1 /* OrderStatus.Canceled */ ? order.limitPrice : undefined;\n        }\n        if (order.stopPrice !== undefined) {\n          entity.stopLoss = order.status !== 1 /* OrderStatus.Canceled */ ? order.stopPrice : undefined;\n        }\n        if (order.parentType === 2 /* ParentType.Position */) {\n          return this._updatePosition(entity);\n        }\n        this._updateOrder(entity);\n      }\n    }\n    /** Updates a given position */\n  }, {\n    key: \"_updatePosition\",\n    value: function _updatePosition(position) {\n      var hasPositionAlready = Boolean(this._positionById[position.id]);\n      if (hasPositionAlready && !position.qty) {\n        // Remove symbol from active symbols set if no more orders or positions use it\n        if (!this._isSymbolUsed(position.symbol)) {\n          this._activeSymbols[\"delete\"](position.symbol);\n          this._unsubscribeRealtimeIfNeeded(position.symbol);\n        }\n        var index = this._positions.indexOf(position);\n        if (index !== -1) {\n          this._positions.splice(index, 1);\n        }\n        delete this._positionById[position.id];\n        this._host.positionUpdate(position);\n        return;\n      }\n      console.log(\"placeOrder _updatePosition\", position);\n      if (!hasPositionAlready) {\n        this._positions.push(position);\n        this._activeSymbols.add(position.symbol);\n        // Subscribe to real-time updates for the symbol\n        this._ensureRealtimeSubscription(position.symbol);\n      }\n      this._positionById[position.id] = position;\n      this._host.positionUpdate(position);\n    }\n  }, {\n    key: \"_ensureRealtimeSubscription\",\n    value: function _ensureRealtimeSubscription(symbol) {\n      if (!this._isSubscribedToRealtime(symbol)) {\n        this.subscribeRealtime(symbol);\n      }\n    }\n  }, {\n    key: \"_unsubscribeRealtimeIfNeeded\",\n    value: function _unsubscribeRealtimeIfNeeded(symbol) {\n      if (!this._isSymbolUsed(symbol) && this._isSubscribedToRealtime(symbol)) {\n        this.unsubscribeRealtime(symbol);\n      }\n    }\n  }, {\n    key: \"_isSymbolUsed\",\n    value: function _isSymbolUsed(symbol) {\n      // Check if any orders or positions are using the symbol\n      return Object.values(this._orderById).some(function (order) {\n        return order.symbol === symbol;\n      }) || Object.values(this._positionById).some(function (position) {\n        return position.symbol === symbol;\n      });\n    }\n  }, {\n    key: \"_isSubscribedToRealtime\",\n    value: function _isSubscribedToRealtime(symbol) {\n      return this._subscribedSymbols.has(symbol);\n    }\n    /** Subscribes to receive real-time quotes for a specific symbol */\n    // private _subscribeData(\n    //   symbol: string,\n    //   id: string,\n    //   updateFunction: (last: number) => void\n    // ): void {\n    //   this._quotesProvider.subscribeQuotes(\n    //     [],\n    //     [symbol],\n    //     (symbols: QuoteData[]) => {\n    //       const deltaData = symbols[0];\n    //       if (deltaData.s !== \"ok\") {\n    //         return;\n    //       }\n    //       if (typeof deltaData.v.lp === \"number\") {\n    //         updateFunction(deltaData.v.lp);\n    //       }\n    //     },\n    //     getDatafeedSubscriptionId(id)\n    //   );\n    // }\n    /** Unsubscribes the data listener associated with the provided ID from receiving real-time quote updates */\n    // private _unsubscribeData(id: string): void {\n    //   this._quotesProvider.unsubscribeQuotes(getDatafeedSubscriptionId(id));\n    // }\n  }, {\n    key: \"_mapQuoteValuesToTradingQuotes\",\n    value: function _mapQuoteValuesToTradingQuotes(quoteValues) {\n      return {\n        bid: quoteValues.bid,\n        ask: quoteValues.ask,\n        bid_size: quoteValues.bid_size,\n        ask_size: quoteValues.ask_size,\n        trade: quoteValues.last_price || quoteValues.lp,\n        // Use 'lp' or 'last_price' for the last price\n        size: quoteValues.volume\n        // spread: quoteValues.spread,\n        // Map any other necessary fields\n        // For example:\n        // ch: quoteValues.ch,\n        // chp: quoteValues.chp,\n        // isDelayed: quoteValues.isDelayed,\n        // isHalted: quoteValues.isHalted,\n      };\n    }\n  }, {\n    key: \"subscribeRealtime\",\n    value: function subscribeRealtime(symbol) {\n      var _this13 = this;\n      var adjustedSymbol = this.appendSuffix(symbol.includes(\":\") ? symbol.split(\":\")[1] : symbol);\n      var subscriptionId = getDatafeedSubscriptionId(\"realtime-\".concat(symbol));\n      // Subscribe to the datafeed\n      this._quotesProvider.subscribeQuotes([], [adjustedSymbol], function (quotes) {\n        var quoteData = quotes[0];\n        if (quoteData.s !== \"ok\") {\n          console.error(\"Error in quote data for symbol \".concat(symbol, \": \").concat(quoteData.s));\n          return;\n        }\n        var quoteValues = quoteData.v;\n        var lastPrice = quoteValues.lp;\n        // Check if lastPrice is defined\n        if (lastPrice !== undefined) {\n          // Calculate digits from the last price\n          var digits = _this13.calculateDigitsFromPrice(lastPrice);\n          // Store the digits for the symbol\n          _this13._symbolDigits[symbol] = digits;\n        } else {\n          // Handle the case where lastPrice is undefined\n          // You can set a default number of digits, e.g., 5\n          _this13._symbolDigits[symbol] = 5; // Default value; adjust as necessary\n        }\n        // Map DatafeedQuoteValues to TradingQuotes\n        var tradingQuotes = _this13._mapQuoteValuesToTradingQuotes(quoteValues);\n        // Call the host's realtimeUpdate method\n        _this13._host.realtimeUpdate(symbol, tradingQuotes);\n        // Process the real-time data to update orders and positions\n        _this13._handleRealTimeUpdate(symbol, quoteValues);\n      }, subscriptionId);\n      this._subscribedSymbols.add(symbol);\n      console.log(\"Subscribed to real-time updates for \".concat(symbol, \" with ID \").concat(subscriptionId));\n    }\n  }, {\n    key: \"calculateDigitsFromPrice\",\n    value: function calculateDigitsFromPrice(price) {\n      if (price === undefined) {\n        return 0; // Or throw an error, or return a default value\n      }\n      var priceStr = price.toString();\n      var decimalIndex = priceStr.indexOf('.');\n      if (decimalIndex === -1) return 0; // No decimal point means zero digits\n      var fractionalPart = priceStr.slice(decimalIndex + 1);\n      return fractionalPart.length;\n    }\n  }, {\n    key: \"unsubscribeRealtime\",\n    value: function unsubscribeRealtime(symbol) {\n      var subscriptionId = getDatafeedSubscriptionId(\"realtime-\".concat(symbol));\n      this._quotesProvider.unsubscribeQuotes(subscriptionId);\n      this._subscribedSymbols[\"delete\"](symbol);\n      console.log(\"Unsubscribed from real-time updates for \".concat(symbol, \" with ID \").concat(subscriptionId));\n    }\n  }, {\n    key: \"_handleRealTimeUpdate\",\n    value: function _handleRealTimeUpdate(symbol, quoteValues) {\n      var _this14 = this;\n      var lastPrice = quoteValues.last_price || quoteValues.lp; // Use 'lp' if 'last_price' is not available\n      if (lastPrice === undefined) {\n        return;\n      }\n      // Update orders\n      Object.values(this._orderById).forEach(function (order) {\n        if (order.symbol === symbol && order.status === 6 /* OrderStatus.Working */) {\n          if (order.last === lastPrice) {\n            return;\n          }\n          order.last = lastPrice;\n          if (order.price == null) {\n            order.price = order.last;\n          }\n          var executionChecks = _defineProperty(_defineProperty({}, -1 /* Side.Sell */, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, 2 /* OrderType.Market */, function _() {\n            return !!order.price;\n          }), 1 /* OrderType.Limit */, function _() {\n            return order.limitPrice !== undefined && order.last >= order.limitPrice;\n          }), 3 /* OrderType.Stop */, function _() {\n            return order.stopPrice !== undefined && order.last <= order.stopPrice;\n          }), 4 /* OrderType.StopLimit */, function _() {\n            return false;\n          })), 1 /* Side.Buy */, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, 2 /* OrderType.Market */, function _() {\n            return !!order.price;\n          }), 1 /* OrderType.Limit */, function _() {\n            return order.limitPrice !== undefined && order.last <= order.limitPrice;\n          }), 3 /* OrderType.Stop */, function _() {\n            return order.stopPrice !== undefined && order.last >= order.stopPrice;\n          }), 4 /* OrderType.StopLimit */, function _() {\n            return false;\n          }));\n          if (executionChecks[order.side][order.type]()) {\n            var positionData = _objectSpread({}, order);\n            order.price = order.last;\n            order.avgPrice = order.last;\n            var _position = _this14._createPositionForOrder(positionData);\n            order.status = 2 /* OrderStatus.Filled */;\n            _this14._updateOrder(order);\n            // Execute bracket orders\n            _this14._getBrackets(order.id).forEach(function (bracket) {\n              bracket.status = 6 /* OrderStatus.Working */;\n              bracket.parentId = _position.id;\n              bracket.parentType = 2 /* ParentType.Position */;\n              _this14._updateOrder(bracket);\n            });\n          }\n          _this14._updateOrderLast(order);\n        }\n      });\n      // Update positions\n      Object.values(this._positionById).forEach(function (position) {\n        if (position.symbol === symbol) {\n          if (position.last === lastPrice) {\n            return;\n          }\n          position.last = lastPrice;\n          position.profit = (position.last - position.price) * position.qty * (position.side === -1 /* Side.Sell */ ? -1 : 1);\n          _this14._host.plUpdate(position.symbol, position.profit);\n          _this14._host.positionPartialUpdate(position.id, position);\n          // this._recalculateAMData();\n        }\n      });\n    }\n    // private handleRealTimeUpdate(\n    //   symbol: string,\n    //   quoteValues: DatafeedQuoteValues\n    // ): void {\n    //   // Map DatafeedQuoteValues to TradingQuotes\n    //   const data: TradingQuotes = {\n    //     bid: quoteValues.bid,\n    //     ask: quoteValues.ask,\n    //     bid_size: quoteValues.bid_size,\n    //     ask_size: quoteValues.ask_size,\n    //     trade: quoteValues.last_price,\n    //     size: quoteValues.volume,\n    //     // Include other properties as needed\n    //   };\n    //   console.log(\"handleRealTimeUpdate\", data);\n    //   // Call the host's realtimeUpdate method to update the chart\n    //   this._host.realtimeUpdate(symbol, data);\n    // }\n    /** Recalculates equity and profit and loss values that are displayed in the Account Manager */\n    // private _recalculateAMData(): void {\n    //   let pl = 0;\n    //   this._positions.forEach((position: Position) => {\n    //     pl += position.profit || 0;\n    //   });\n    //   this._accountManagerData.pl = pl;\n    //   this._accountManagerData.equity = this._accountManagerData.balance + pl;\n    //   // Evoke event: notify all subscribers that values in the Account Manager are updated\n    //   this._amChangeDelegate.fire(this._accountManagerData);\n    // }\n  }, {\n    key: \"getSymbolName\",\n    value: function getSymbolName(symbol) {\n      return symbol.includes(\":\") ? symbol.split(\":\")[1] : symbol;\n    }\n    /** Creates an order with bracket orders and returns an array of data objects representing these orders */\n  }, {\n    key: \"_createOrderWithBrackets\",\n    value: function _createOrderWithBrackets(preOrder) {\n      var orders = [];\n      var order = this._createOrder(preOrder);\n      orders.push(order);\n      // If true, create a take-profit order\n      if (order.takeProfit !== undefined) {\n        var takeProfit = this._createTakeProfitBracket(order);\n        orders.push(takeProfit);\n      }\n      // If true, create a stop-loss order\n      if (order.stopLoss !== undefined) {\n        var stopLoss = this._createStopLossBracket(order);\n        orders.push(stopLoss);\n      }\n      return orders;\n    }\n    /** Gets an array of bracket order objects associated with a specific parent ID */\n  }, {\n    key: \"_getBrackets\",\n    value: function _getBrackets(parentId) {\n      return this._orders().filter(function (order) {\n        return order.parentId === parentId && activeOrderStatuses.includes(order.status);\n      });\n    }\n    /** Creates a working order based on the `PreOrder` object and returns an object that contains information about this order */\n  }, {\n    key: \"_createOrder\",\n    value: function _createOrder(preOrder) {\n      return {\n        id: \"\".concat(this._idsCounter++),\n        duration: preOrder.duration,\n        // duration is not used in this sample\n        limitPrice: preOrder.limitPrice,\n        profit: 0,\n        qty: preOrder.qty,\n        side: preOrder.side || 1 /* Side.Buy */,\n        status: 6 /* OrderStatus.Working */,\n        stopPrice: preOrder.stopPrice,\n        symbol: preOrder.symbol,\n        type: preOrder.type || 2 /* OrderType.Market */,\n        takeProfit: preOrder.takeProfit,\n        stopLoss: preOrder.stopLoss,\n        symbolName: preOrder.symbol\n      };\n    }\n    /** Creates a take-profit order and returns an object that contains information about this order */\n  }, {\n    key: \"_createTakeProfitBracket\",\n    value: function _createTakeProfitBracket(entity) {\n      return {\n        symbol: entity.symbol,\n        qty: entity.qty,\n        id: \"\".concat(this._idsCounter++),\n        parentId: entity.id,\n        parentType: 1 /* ParentType.Order */,\n        limitPrice: entity.takeProfit,\n        side: changeSide(entity.side),\n        status: 3 /* OrderStatus.Inactive */,\n        type: 1 /* OrderType.Limit */,\n        symbolName: entity.symbol\n      };\n    }\n    /** Creates a stop-loss order and returns an object that contains information about this order */\n  }, {\n    key: \"_createStopLossBracket\",\n    value: function _createStopLossBracket(entity) {\n      return {\n        symbol: entity.symbol,\n        qty: entity.qty,\n        id: \"\".concat(this._idsCounter++),\n        parentId: entity.id,\n        parentType: 1 /* ParentType.Order */,\n        stopPrice: entity.stopLoss,\n        price: entity.stopPrice,\n        side: changeSide(entity.side),\n        status: 3 /* OrderStatus.Inactive */,\n        type: 3 /* OrderType.Stop */,\n        symbolName: entity.symbol\n      };\n    }\n    /** Gets a take-profit order by searching among the orders associated with a given order or position that has a non-undefined `limitPrice` */\n  }, {\n    key: \"_getTakeProfitBracket\",\n    value: function _getTakeProfitBracket(entity) {\n      return this._getBrackets(entity.id).find(function (bracket) {\n        return bracket.limitPrice !== undefined;\n      });\n    }\n    /** Gets a stop-loss order by searching among the orders associated with a given order or position that has a non-undefined `stopPrice` */\n  }, {\n    key: \"_getStopLossBracket\",\n    value: function _getStopLossBracket(entity) {\n      return this._getBrackets(entity.id).find(function (bracket) {\n        return bracket.stopPrice !== undefined;\n      });\n    }\n    /** Updates the orders' bracket orders based on the provided parameters */\n  }, {\n    key: \"_updateOrdersBracket\",\n    value: function _updateOrdersBracket(params) {\n      var parent = params.parent,\n        bracket = params.bracket,\n        bracketType = params.bracketType,\n        newPrice = params.newPrice;\n      // Check if the bracket should be canceled\n      var shouldCancelBracket = bracket !== undefined && newPrice === undefined;\n      if (shouldCancelBracket) {\n        // Set the bracket order status to \"Canceled\"\n        this._setCanceledStatusAndUpdate(bracket);\n        return;\n      }\n      if (newPrice === undefined) {\n        return;\n      }\n      // Check if a new bracket should be created\n      var shouldCreateNewBracket = bracket === undefined;\n      // Handle the take-profit bracket order type\n      if (bracketType === 1 /* BracketType.TakeProfit */) {\n        var takeProfitBracket = shouldCreateNewBracket ? this._createTakeProfitBracket(parent) : _objectSpread(_objectSpread({}, bracket), {}, {\n          limitPrice: newPrice\n        });\n        this._updateOrder(takeProfitBracket);\n        return;\n      }\n      // Handle the stop-loss bracket order type\n      if (bracketType === 0 /* BracketType.StopLoss */) {\n        var stopLossBracket = shouldCreateNewBracket ? this._createStopLossBracket(parent) : _objectSpread(_objectSpread({}, bracket), {}, {\n          stopPrice: newPrice\n        });\n        this._updateOrder(stopLossBracket);\n        return;\n      }\n    }\n    /** Updates the positions' bracket orders based on the provided parameters */\n  }, {\n    key: \"_updatePositionsBracket\",\n    value: function _updatePositionsBracket(params) {\n      console.log(\"placeOrder _updatePositionsBracket\", params);\n      var parent = params.parent,\n        bracket = params.bracket,\n        bracketType = params.bracketType,\n        newPrice = params.newPrice;\n      // Check if the bracket should be canceled\n      var shouldCancelBracket = bracket !== undefined && newPrice === undefined;\n      if (shouldCancelBracket) {\n        // Set the bracket order status to \"Canceled\"\n        this._setCanceledStatusAndUpdate(bracket);\n        return;\n      }\n      if (newPrice === undefined) {\n        return;\n      }\n      // Check if a new bracket should be created\n      var shouldCreateNewBracket = bracket === undefined;\n      // Handle the take-profit bracket order type\n      if (bracketType === 1 /* BracketType.TakeProfit */) {\n        // If `true`, create a new take-profit bracket\n        if (shouldCreateNewBracket) {\n          var takeProfitBracket = this._createTakeProfitBracket(parent);\n          takeProfitBracket.status = 6 /* OrderStatus.Working */;\n          takeProfitBracket.parentType = 2 /* ParentType.Position */;\n          this._updateOrder(takeProfitBracket);\n          return;\n        }\n        // Update the existing bracket order with a new take-profit price\n        bracket.limitPrice = newPrice;\n        bracket.takeProfit = newPrice;\n        this._updateOrder(bracket);\n        return;\n      }\n      // Handle the stop-loss bracket order type\n      if (bracketType === 0 /* BracketType.StopLoss */) {\n        // If `true`, create a new stop-loss bracket\n        if (shouldCreateNewBracket) {\n          var stopLossBracket = this._createStopLossBracket(parent);\n          stopLossBracket.status = 6 /* OrderStatus.Working */;\n          stopLossBracket.parentType = 2 /* ParentType.Position */;\n          this._updateOrder(stopLossBracket);\n          return;\n        }\n        // Update the existing bracket order with a new stop-loss price\n        bracket.stopPrice = newPrice;\n        bracket.stopLoss = newPrice;\n        this._updateOrder(bracket);\n        return;\n      }\n    }\n    /** Sets the order status to \"Canceled\" and updates the order object */\n  }, {\n    key: \"_setCanceledStatusAndUpdate\",\n    value: function _setCanceledStatusAndUpdate(order) {\n      order.status = 1 /* OrderStatus.Canceled */;\n      this._updateOrder(order);\n    }\n    /** Sets the order status to \"Filled\" and updates the order object */\n  }, {\n    key: \"_setFilledStatusAndUpdate\",\n    value: function _setFilledStatusAndUpdate(order) {\n      order.status = 2 /* OrderStatus.Filled */;\n      this._updateOrder(order);\n    }\n  }]);\n}();\nBrokerSample.accountTypeIdToSuffixMap = {\n  // ECN accounts\n  57: \".\",\n  61: \".\",\n  65: \".\",\n  // Standard accounts\n  58: \"!\",\n  62: \"!\",\n  66: \"!\",\n  // ECNPRO accounts (no suffix)\n  59: \"\",\n  63: \"\",\n  67: \"\",\n  // Social accounts\n  60: \"#\",\n  64: \"#\"\n};\n/** Changes the position or order side to its opposite and returns the modified `side` property */\nfunction changeSide(side) {\n  return side === 1 /* Side.Buy */ ? -1 /* Side.Sell */ : 1 /* Side.Buy */;\n}\n/** Gets a datafeed subscription ID */\nfunction getDatafeedSubscriptionId(id) {\n  return \"SampleBroker-\".concat(id);\n}\n\n//# sourceURL=webpack://trading_terminal/./broker-sample/lib/broker.js?");

/***/ }),

/***/ "./broker-sample/lib/columns.js":
/*!**************************************!*\
  !*** ./broker-sample/lib/columns.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accountSummaryColumns: () => (/* binding */ accountSummaryColumns),\n/* harmony export */   historyPageColumns: () => (/* binding */ historyPageColumns),\n/* harmony export */   ordersPageColumns: () => (/* binding */ ordersPageColumns),\n/* harmony export */   positionsPageColumns: () => (/* binding */ positionsPageColumns)\n/* harmony export */ });\n/**\n * Column structure for the \"Orders\" page\n */\nvar ordersPageColumns = [{\n  label: \"Time\",\n  id: \"time\",\n  dataFields: [\"timeSetup\"],\n  formatter: \"date\" /* StandardFormatterName.Date */\n}, {\n  label: \"Symbol\",\n  formatter: \"symbol\" /* StandardFormatterName.Symbol */,\n  id: \"symbol\" /* CommonAccountManagerColumnId.Symbol */,\n  dataFields: [\"symbolName\", \"symbolName\", \"message\"]\n}, {\n  label: \"Side\",\n  id: \"side\",\n  dataFields: [\"side\"],\n  formatter: \"side\" /* StandardFormatterName.Side */\n}, {\n  label: \"Type\",\n  id: \"type\",\n  dataFields: [\"type\", \"parentId\", \"stopType\"],\n  formatter: \"type\" /* StandardFormatterName.Type */\n}, {\n  label: \"Qty\",\n  alignment: \"right\",\n  id: \"qty\",\n  dataFields: [\"qty\"],\n  help: \"Size in lots\"\n}, {\n  label: \"Limit Price\",\n  alignment: \"right\",\n  id: \"limitPrice\",\n  dataFields: [\"limitPrice\"],\n  formatter: \"formatPrice\" /* StandardFormatterName.FormatPrice */\n}, {\n  label: \"Stop Price\",\n  alignment: \"right\",\n  id: \"stopPrice\",\n  dataFields: [\"stopPrice\"],\n  formatter: \"formatPrice\" /* StandardFormatterName.FormatPrice */\n}, {\n  label: \"Last\",\n  alignment: \"right\",\n  id: \"last\",\n  dataFields: [\"last\"],\n  formatter: \"formatPriceForexSup\" /* StandardFormatterName.FormatPriceForexSup */,\n  highlightDiff: true\n}, {\n  label: \"Execution\",\n  id: \"execution\",\n  dataFields: [\"execution\"]\n}, {\n  label: \"Status\",\n  id: \"status\",\n  dataFields: [\"status\"],\n  formatter: \"status\" /* StandardFormatterName.Status */,\n  supportedStatusFilters: [0 /* OrderStatusFilter.All */]\n}, {\n  label: \"Order ID\",\n  id: \"id\",\n  alignment: \"left\",\n  dataFields: [\"id\"]\n}];\n/**\n * Column structure for the \"Positions\" page\n */\nvar positionsPageColumns = [{\n  label: \"Time\",\n  id: \"time\",\n  dataFields: [\"timeCreate\"],\n  formatter: \"date\" /* StandardFormatterName.Date */\n}, {\n  label: \"Symbol\",\n  formatter: \"symbol\" /* StandardFormatterName.Symbol */,\n  id: \"symbol\" /* CommonAccountManagerColumnId.Symbol */,\n  dataFields: [\"symbolName\", \"symbolName\", \"message\"]\n}, {\n  label: \"Side\",\n  id: \"side\",\n  dataFields: [\"side\"],\n  formatter: \"side\" /* StandardFormatterName.Side */\n}, {\n  label: \"Volume\",\n  alignment: \"right\",\n  id: \"qty\",\n  dataFields: [\"qty\"],\n  help: \"Size in lots\"\n}, {\n  label: \"Open Price\",\n  alignment: \"right\",\n  id: \"avgPrice\",\n  dataFields: [\"avgPrice\"],\n  formatter: \"formatPrice\" /* StandardFormatterName.FormatPrice */\n}, {\n  label: \"Current\",\n  alignment: \"right\",\n  id: \"last\",\n  dataFields: [\"last\"],\n  formatter: \"formatPriceForexSup\" /* StandardFormatterName.FormatPriceForexSup */,\n  highlightDiff: true\n}, {\n  label: \"Profit\",\n  alignment: \"right\",\n  id: \"pl\",\n  dataFields: [\"pl\"],\n  formatter: \"profit\" /* StandardFormatterName.Profit */\n}, {\n  label: \"Stop Loss\",\n  alignment: \"right\",\n  id: \"stopLoss\",\n  dataFields: [\"stopLoss\"]\n}, {\n  label: \"Take Profit\",\n  alignment: \"right\",\n  id: \"takeProfit\",\n  dataFields: [\"takeProfit\"]\n}, {\n  label: \"Position ID\",\n  alignment: \"left\",\n  id: \"id\",\n  dataFields: [\"id\"]\n}];\n/**\n * Column structure for the custom \"Account Summary\" page\n */\nvar accountSummaryColumns = [{\n  label: \"Title\",\n  notSortable: true,\n  id: \"title\",\n  dataFields: [\"title\"],\n  formatter: \"custom_uppercase\"\n}, {\n  label: \"Balance\",\n  alignment: \"right\",\n  id: \"balance\",\n  dataFields: [\"balance\"],\n  formatter: \"fixed\" /* StandardFormatterName.Fixed */\n}, {\n  label: \"Open PL\",\n  alignment: \"right\",\n  id: \"pl\",\n  dataFields: [\"pl\"],\n  formatter: \"profit\" /* StandardFormatterName.Profit */,\n  notSortable: true\n}, {\n  label: \"Equity\",\n  alignment: \"right\",\n  id: \"equity\",\n  dataFields: [\"equity\"],\n  formatter: \"fixed\" /* StandardFormatterName.Fixed */,\n  notSortable: true\n}];\n/**\n * Column structure for the \"History\" page\n */\nvar historyPageColumns = [{\n  label: \"Time\",\n  id: \"time\",\n  dataFields: [\"timeSetup\"],\n  formatter: \"date\" /* StandardFormatterName.Date */\n}, {\n  label: \"Symbol\",\n  formatter: \"symbol\" /* StandardFormatterName.Symbol */,\n  id: \"symbol\" /* CommonAccountManagerColumnId.Symbol */,\n  dataFields: [\"symbol\", \"symbol\", \"message\"]\n}, {\n  label: \"Side\",\n  id: \"side\",\n  dataFields: [\"side\"],\n  formatter: \"side\" /* StandardFormatterName.Side */\n}, {\n  label: \"Quantity\",\n  alignment: \"right\",\n  id: \"qty\",\n  dataFields: [\"qty\"],\n  formatter: \"fixed\" /* StandardFormatterName.Fixed */\n}, {\n  label: \"Limit Price\",\n  alignment: \"right\",\n  id: \"limitPrice\",\n  dataFields: [\"limitPrice\"],\n  formatter: \"formatPrice\" /* StandardFormatterName.FormatPrice */\n}, {\n  label: \"Stop Price\",\n  alignment: \"right\",\n  id: \"stopPrice\",\n  dataFields: [\"stopPrice\"],\n  formatter: \"formatPrice\" /* StandardFormatterName.FormatPrice */\n}, {\n  label: \"Take Profit\",\n  alignment: \"right\",\n  id: \"takeProfit\",\n  dataFields: [\"takeProfit\"]\n}, {\n  label: \"Status\",\n  id: \"status\",\n  dataFields: [\"status\"],\n  formatter: \"status\" /* StandardFormatterName.Status */\n}, {\n  label: \"Order ID\",\n  notSortable: true,\n  id: \"id\",\n  dataFields: [\"id\"]\n}];\n\n//# sourceURL=webpack://trading_terminal/./broker-sample/lib/columns.js?");

/***/ }),

/***/ "./broker-sample/lib/helpers.js":
/*!**************************************!*\
  !*** ./broker-sample/lib/helpers.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeApiRequest: () => (/* binding */ makeApiRequest),\n/* harmony export */   makeCRMApiRequest: () => (/* binding */ makeCRMApiRequest),\n/* harmony export */   makePostApiRequest: () => (/* binding */ makePostApiRequest)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction makeApiRequest(_x, _x2) {\n  return _makeApiRequest.apply(this, arguments);\n}\nfunction _makeApiRequest() {\n  _makeApiRequest = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(path, params) {\n    var paramKeys, headers, response;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (params !== undefined) {\n            paramKeys = Object.keys(params);\n            if (paramKeys.length !== 0) {\n              path += \"?\";\n            }\n            path += paramKeys.map(function (key) {\n              return \"\".concat(encodeURIComponent(key), \"=\").concat(encodeURIComponent(params[key].toString()));\n            }).join(\"&\");\n          }\n          headers = {\n            Authorization: \"Bearer \".concat(localStorage.getItem(\"token\"))\n          };\n          _context.next = 4;\n          return fetch(\"\".concat(path), {\n            headers: headers\n          });\n        case 4:\n          response = _context.sent;\n          return _context.abrupt(\"return\", response.json());\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _makeApiRequest.apply(this, arguments);\n}\nfunction makePostApiRequest(_x3, _x4) {\n  return _makePostApiRequest.apply(this, arguments);\n}\nfunction _makePostApiRequest() {\n  _makePostApiRequest = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(path, body) {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return fetch(\"\".concat(path), {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\",\n              \"Authorization\": \"Bearer \".concat(localStorage.getItem(\"token\"))\n            },\n            body: JSON.stringify(body)\n          });\n        case 2:\n          response = _context2.sent;\n          return _context2.abrupt(\"return\", response.json());\n        case 4:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _makePostApiRequest.apply(this, arguments);\n}\nfunction makeCRMApiRequest(_x5, _x6) {\n  return _makeCRMApiRequest.apply(this, arguments);\n}\nfunction _makeCRMApiRequest() {\n  _makeCRMApiRequest = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(path, body) {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return fetch(\"\".concat(path), {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\",\n              \"Authorization\": \"Bearer \".concat(localStorage.getItem(\"crm_token\"))\n            },\n            body: JSON.stringify(body)\n          });\n        case 2:\n          response = _context3.sent;\n          return _context3.abrupt(\"return\", response.json());\n        case 4:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _makeCRMApiRequest.apply(this, arguments);\n}\n\n//# sourceURL=webpack://trading_terminal/./broker-sample/lib/helpers.js?");

/***/ }),

/***/ "./broker-sample/lib/streaming.js":
/*!****************************************!*\
  !*** ./broker-sample/lib/streaming.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BalanceEquityStreaming: () => (/* binding */ BalanceEquityStreaming)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar BalanceEquityStreaming = /*#__PURE__*/function () {\n  function BalanceEquityStreaming(loginNumber) {\n    _classCallCheck(this, BalanceEquityStreaming);\n    this.ws = null;\n    this.updateCallbacks = [];\n    // this.reconnectInterval = reconnectInterval;\n    this.loginNumber = loginNumber;\n    // Initiate the WebSocket connection\n    this.connect();\n  }\n  // Method to connect to the WebSocket\n  return _createClass(BalanceEquityStreaming, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this = this;\n      this.ws = new WebSocket(\"wss://opotrade.azurewebsites.net/ws?login=\".concat(this.loginNumber, \"&methodtype=GetTradeState&TP=3\"));\n      // Handle WebSocket open event\n      this.ws.onopen = function () {\n        console.log(\"WebSocket connection established\");\n        // You might want to send an initial request here if required\n      };\n      // Handle incoming messages\n      this.ws.onmessage = function (event) {\n        //console.log(\"WebSocket message received:\", JSON.parse(event.data));\n        var data = JSON.parse(event.data).answer;\n        var balance = parseFloat(data.Balance);\n        var equity = parseFloat(data.Equity);\n        var pl = parseFloat(data.Profit);\n        // if(balance && equity){\n        //   this.updateCallbacks.forEach((callback) => {\n        //     // Create a new object for each callback to avoid passing references\n        //     const balanceEquityData:BalanceEquityData = { balance: balance, equity: equity,pl :pl};\n        //     callback({ ...balanceEquityData }); // Spread the object to ensure a new copy\n        // });\n        // }\n        _this.updateCallbacks.forEach(function (callback) {\n          var balanceEquityData = {\n            balance: balance,\n            equity: equity,\n            pl: pl\n          };\n          callback(_objectSpread({}, balanceEquityData));\n        });\n      };\n      // Handle WebSocket close event and try to reconnect\n      this.ws.onclose = function () {\n        console.log(\"WebSocket connection closed. Attempting to reconnect...\");\n      };\n      // Handle WebSocket errors\n      this.ws.onerror = function (error) {\n        console.error(\"WebSocket error:\", error);\n      };\n    }\n    // Subscribe to balance and equity updates\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(callback) {\n      this.updateCallbacks.push(callback);\n    }\n    // Unsubscribe from balance and equity updates\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(callback) {\n      console.log(\"Closing Unsubscribing from balance and equity updates...\");\n      this.updateCallbacks = this.updateCallbacks.filter(function (cb) {\n        return cb !== callback;\n      });\n    }\n    // Close the WebSocket connection manually\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this.ws) {\n        console.log(\"Closing WebSocket connection...\");\n        this.ws.close();\n        this.ws = null;\n        this.updateCallbacks = [];\n      }\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://trading_terminal/./broker-sample/lib/streaming.js?");

/***/ }),

/***/ "./src/datafeed.js":
/*!*************************!*\
  !*** ./src/datafeed.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"./src/helpers.js\");\n/* harmony import */ var _streaming_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./streaming.js */ \"./src/streaming.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\nvar source = \"tv\";\nvar bartDataType = \"dhloc\";\nvar lastBarsCache = new Map();\nvar fromDate = new Date();\nfromDate.setMonth(fromDate.getMonth() - 1);\nfromDate.setHours(0, 0, 0, 0);\nvar timeOffset = 3 * 60 * 60;\nvar Datafeed = /*#__PURE__*/function () {\n  function Datafeed() {\n    var _this = this;\n    _classCallCheck(this, Datafeed);\n    _defineProperty(this, \"configurationData\", void 0);\n    _defineProperty(this, \"resolveSymbol\", /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(symbolName, onSymbolResolvedCallback, onResolveErrorCallback, extension) {\n        var _data$data, s1, symbolWithSuffix, requestParams, data, symbolItem, symbolWithoutSuffix, symbolInfo;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              console.log(\"[resolveSymbol]: Method call\", symbolName);\n              _context.prev = 1;\n              s1 = symbolName.replace(\"Opofinance:\", \"\"); // Append suffix to the symbol\n              symbolWithSuffix = _this.appendSuffix(s1);\n              requestParams = {\n                symbol: symbolWithSuffix,\n                source: source\n              };\n              _context.next = 7;\n              return _this.retryApiRequest(\"api/Symbol/getsymbolsbyname\", requestParams);\n            case 7:\n              data = _context.sent;\n              if (!((_data$data = data.data) !== null && _data$data !== void 0 && _data$data[0])) {\n                _context.next = 15;\n                break;\n              }\n              symbolItem = data.data[0]; // Remove suffix before returning to client\n              symbolWithoutSuffix = _this.removeSuffix(symbolItem.name);\n              symbolInfo = {\n                ticker: symbolWithoutSuffix,\n                name: symbolWithoutSuffix,\n                description: symbolItem.description,\n                type: symbolItem.type,\n                session: symbolItem.session,\n                timezone: symbolItem.timezone,\n                exchange: symbolItem.exchange,\n                minmov: symbolItem.minmov,\n                pricescale: symbolItem.pricescale,\n                has_intraday: symbolItem.has_intraday,\n                has_weekly_and_monthly: symbolItem.has_weekly_and_monthly,\n                supported_resolutions: symbolItem.supported_resolutions,\n                intraday_multipliers: [\"1\"],\n                has_empty_bars: symbolItem.has_empty_bars,\n                listed_exchange: symbolItem.listed_exchange,\n                visible_plots_set: symbolItem.visible_plots_set,\n                currency_code: symbolItem.currency_code,\n                volume_precision: symbolItem.volume_precision,\n                data_status: symbolItem.data_status,\n                sector: symbolItem.sector,\n                industry: symbolItem.industry,\n                delay: symbolItem.delay,\n                format: symbolItem.format\n              };\n              onSymbolResolvedCallback(symbolInfo);\n              _context.next = 17;\n              break;\n            case 15:\n              onResolveErrorCallback(\"unknown_symbol\");\n              return _context.abrupt(\"return\");\n            case 17:\n              _context.next = 23;\n              break;\n            case 19:\n              _context.prev = 19;\n              _context.t0 = _context[\"catch\"](1);\n              console.error(\"[resolveSymbol]: Failed to resolve symbol, error=\", _context.t0);\n              onResolveErrorCallback(\"unknown_symbol\");\n            case 23:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[1, 19]]);\n      }));\n      return function (_x, _x2, _x3, _x4) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    this.configurationData = {\n      exchanges: [{\n        value: \"Opofinance\",\n        name: \"Opofinance\",\n        desc: \"Opofinance\"\n      }],\n      supported_resolutions: [\"1\", \"5\", \"15\", \"30\", \"60\", \"240\", \"1D\", \"1W\", \"1M\"],\n      symbols_types: [{\n        name: \"All types\",\n        value: \"\"\n      }, {\n        name: \"Forex\",\n        value: \"forex\"\n      }, {\n        name: \"Metals\",\n        value: \"metals\"\n      }, {\n        name: \"Commodities\",\n        value: \"commodities\"\n      }, {\n        name: \"Stocks\",\n        value: \"stocks\"\n      }, {\n        name: \"Indices\",\n        value: \"indices\"\n      }, {\n        name: \"Cryptocurrencies\",\n        value: \"crypto\"\n      }],\n      supports_marks: true,\n      supports_time: true,\n      supports_timescale_marks: true\n    };\n  }\n\n  // Retry helper function\n  return _createClass(Datafeed, [{\n    key: \"retryApiRequest\",\n    value: function () {\n      var _retryApiRequest = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url) {\n        var params,\n          retries,\n          delay,\n          attempt,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              params = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n              retries = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : 4;\n              delay = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : 100;\n              attempt = 1;\n            case 4:\n              if (!(attempt <= retries)) {\n                _context2.next = 28;\n                break;\n              }\n              _context2.prev = 5;\n              _context2.next = 8;\n              return (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.makeApiRequest)(url, params);\n            case 8:\n              return _context2.abrupt(\"return\", _context2.sent);\n            case 11:\n              _context2.prev = 11;\n              _context2.t0 = _context2[\"catch\"](5);\n              if (!(_context2.t0.status === 400)) {\n                _context2.next = 24;\n                break;\n              }\n              if (!(attempt < retries)) {\n                _context2.next = 20;\n                break;\n              }\n              console.warn(\"[retryApiRequest]: Attempt \".concat(attempt, \" failed with 400 error. Retrying in \").concat(delay, \"ms...\"));\n              _context2.next = 18;\n              return this.sleep(delay);\n            case 18:\n              _context2.next = 22;\n              break;\n            case 20:\n              console.error(\"[retryApiRequest]: All \".concat(retries, \" attempts failed with 400 error.\"));\n              throw _context2.t0;\n            case 22:\n              _context2.next = 25;\n              break;\n            case 24:\n              throw _context2.t0;\n            case 25:\n              attempt++;\n              _context2.next = 4;\n              break;\n            case 28:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[5, 11]]);\n      }));\n      function retryApiRequest(_x5) {\n        return _retryApiRequest.apply(this, arguments);\n      }\n      return retryApiRequest;\n    }() // Helper function to pause execution for a specified time\n  }, {\n    key: \"sleep\",\n    value: function sleep(ms) {\n      return new Promise(function (resolve) {\n        return setTimeout(resolve, ms);\n      });\n    }\n\n    // Helper function to get the current suffix\n  }, {\n    key: \"getSuffix\",\n    value: function getSuffix() {\n      return localStorage.getItem(\"suffix\") || \"\";\n    }\n\n    // Helper function to append the suffix\n  }, {\n    key: \"appendSuffix\",\n    value: function appendSuffix(symbol) {\n      var suffix = this.getSuffix();\n      if (suffix && symbol && !symbol.endsWith(suffix)) {\n        return symbol + suffix;\n      }\n      return symbol;\n    }\n\n    // Helper function to remove the suffix\n  }, {\n    key: \"removeSuffix\",\n    value: function removeSuffix(symbol) {\n      var suffix = this.getSuffix();\n      if (suffix && symbol && symbol.endsWith(suffix)) {\n        return symbol.slice(0, -suffix.length);\n      }\n      return symbol;\n    }\n  }, {\n    key: \"onReady\",\n    value: function onReady(callback) {\n      var _this2 = this;\n      setTimeout(function () {\n        return callback(_this2.configurationData);\n      });\n    }\n  }, {\n    key: \"getServerTime\",\n    value: function () {\n      var _getServerTime = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(callback) {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.prev = 0;\n              _context3.next = 3;\n              return this.retryApiRequest(\"api/Test/getServerTime\");\n            case 3:\n              data = _context3.sent;\n              if (data !== null && data !== void 0 && data.unixTimestamp) {\n                callback(data.unixTimestamp);\n              }\n              _context3.next = 10;\n              break;\n            case 7:\n              _context3.prev = 7;\n              _context3.t0 = _context3[\"catch\"](0);\n              console.error(\"[getServerTime]: Failed to load server time, error=\", _context3.t0);\n            case 10:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[0, 7]]);\n      }));\n      function getServerTime(_x6) {\n        return _getServerTime.apply(this, arguments);\n      }\n      return getServerTime;\n    }()\n  }, {\n    key: \"searchSymbols\",\n    value: function () {\n      var _searchSymbols = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(userInput, exchange, symbolType, onResultReadyCallback) {\n        var _this3 = this;\n        var requestParams, data, response, newSymbols;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              requestParams = {\n                mask: (userInput === null || userInput === void 0 ? void 0 : userInput.toUpperCase()) || \"\",\n                source: source\n              };\n              _context4.prev = 1;\n              _context4.next = 4;\n              return this.retryApiRequest(\"api/Symbol/getsymbolsbymask\", requestParams);\n            case 4:\n              data = _context4.sent;\n              if (data !== null && data !== void 0 && data.data) {\n                response = data.data;\n                newSymbols = response.filter(function (item) {\n                  return item.type.toLowerCase() === symbolType.toLowerCase() || symbolType === \"\";\n                }).map(function (item) {\n                  // Remove suffix from symbols before returning\n                  var symbolWithoutSuffix = _this3.removeSuffix(item.name);\n                  return {\n                    symbol: symbolWithoutSuffix,\n                    ticker: symbolWithoutSuffix,\n                    description: item.description,\n                    exchange: item.exchange,\n                    type: item.type,\n                    full_name: symbolWithoutSuffix\n                  };\n                });\n                onResultReadyCallback(newSymbols);\n              } else {\n                onResultReadyCallback([]);\n              }\n              _context4.next = 12;\n              break;\n            case 8:\n              _context4.prev = 8;\n              _context4.t0 = _context4[\"catch\"](1);\n              console.error(\"[searchSymbols]: Failed to search symbols, error=\", _context4.t0);\n              onResultReadyCallback([]);\n            case 12:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[1, 8]]);\n      }));\n      function searchSymbols(_x7, _x8, _x9, _x10) {\n        return _searchSymbols.apply(this, arguments);\n      }\n      return searchSymbols;\n    }()\n  }, {\n    key: \"getUnixTimestamp\",\n    value: function getUnixTimestamp() {\n      return Math.floor(Date.now() / 1000);\n    }\n  }, {\n    key: \"getUnixTimestampOneDayAgo\",\n    value: function getUnixTimestampOneDayAgo() {\n      var secondsInOneDay = 86400;\n      return this.getUnixTimestamp() - secondsInOneDay;\n    }\n  }, {\n    key: \"getBars\",\n    value: function () {\n      var _getBars = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(symbolInfo, resolution, periodParams, onHistoryCallback, onErrorCallback) {\n        var from, to, countBack, firstDataRequest, _data$data$length, _data$data2, adjustedFrom, adjustedTo, symbolWithSuffix, requestParams, data, bars;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              from = periodParams.from, to = periodParams.to, countBack = periodParams.countBack, firstDataRequest = periodParams.firstDataRequest;\n              _context5.prev = 1;\n              adjustedFrom = from + timeOffset;\n              adjustedTo = to + timeOffset; // Append suffix to the symbol\n              symbolWithSuffix = this.appendSuffix(symbolInfo.ticker || \"\");\n              requestParams = {\n                symbol: symbolWithSuffix,\n                from: adjustedFrom,\n                to: adjustedTo,\n                data: bartDataType,\n                source: source,\n                resolution: resolution\n              };\n              _context5.next = 8;\n              return this.retryApiRequest(\"api/Tick/get\", requestParams);\n            case 8:\n              data = _context5.sent;\n              bars = [];\n              if (!(data.errorMessage || !(data !== null && data !== void 0 && data.data) || ((_data$data$length = (_data$data2 = data.data) === null || _data$data2 === void 0 ? void 0 : _data$data2.length) !== null && _data$data$length !== void 0 ? _data$data$length : 0) === 0)) {\n                _context5.next = 13;\n                break;\n              }\n              onHistoryCallback([], {\n                noData: true\n              });\n              return _context5.abrupt(\"return\");\n            case 13:\n              data.data.forEach(function (bar) {\n                bars.push({\n                  time: (bar.time - timeOffset) * 1000,\n                  // Convert to milliseconds\n                  low: bar.low,\n                  high: bar.high,\n                  open: bar.open,\n                  close: bar.close,\n                  volume: bar.volume\n                });\n              });\n              if (bars.length > countBack) {\n                bars = bars.slice(bars.length - countBack);\n              }\n              onHistoryCallback(bars, {\n                noData: false\n              });\n              if (firstDataRequest) {\n                lastBarsCache.set(symbolInfo.ticker, _objectSpread({}, bars[bars.length - 1]));\n              }\n              _context5.next = 23;\n              break;\n            case 19:\n              _context5.prev = 19;\n              _context5.t0 = _context5[\"catch\"](1);\n              console.error(\"[getBars]: Failed to get bars, error=\", _context5.t0);\n              onErrorCallback(_context5.t0);\n            case 23:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[1, 19]]);\n      }));\n      function getBars(_x11, _x12, _x13, _x14, _x15) {\n        return _getBars.apply(this, arguments);\n      }\n      return getBars;\n    }()\n  }, {\n    key: \"subscribeBars\",\n    value: function subscribeBars(symbolInfo, resolution, onRealtimeCallback, listenerGUID, onResetCacheNeededCallback) {\n      console.log(\"[subscribeBars]: Method call with listenerGUID:\", listenerGUID);\n\n      // Append suffix to the symbol\n      var symbolWithSuffix = this.appendSuffix(symbolInfo.name);\n      _streaming_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setSubscriber(\"GetM1History\", listenerGUID, symbolWithSuffix, function (data) {\n        if (data && _typeof(data) === \"object\" && data.time) {\n          console.log(\"[subscribeBars]: Method call :\", data);\n          onRealtimeCallback(data);\n        } else {\n          console.error(\"[SubscribeBars]: Unexpected data type\", data);\n        }\n      });\n    }\n  }, {\n    key: \"unsubscribeBars\",\n    value: function unsubscribeBars(listenerGUID) {\n      console.log(\"[unsubscribeBars]: Method call with listenerGUID:\", listenerGUID);\n      _streaming_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].removeSubscriber(listenerGUID);\n    }\n  }, {\n    key: \"getQuotes\",\n    value: function () {\n      var _getQuotes = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(symbols, onDataCallback, onErrorCallback) {\n        var _this4 = this;\n        var quotes;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.prev = 0;\n              _context7.next = 3;\n              return Promise.all(symbols.map(/*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(symbol) {\n                  var symbolWithSuffix, id, requestParams, response, _response$data$, symbolname, lastprice, ask, bid, volume, symbolWithoutSuffix;\n                  return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                    while (1) switch (_context6.prev = _context6.next) {\n                      case 0:\n                        _context6.prev = 0;\n                        // Append suffix to the symbol\n                        symbolWithSuffix = _this4.appendSuffix(symbol);\n                        id = 1;\n                        requestParams = {\n                          symbol: symbolWithSuffix,\n                          id: id,\n                          source: source\n                        };\n                        _context6.next = 6;\n                        return _this4.retryApiRequest(\"api/Tick/last\", requestParams);\n                      case 6:\n                        response = _context6.sent;\n                        if (!(response.success && response.data.length > 0)) {\n                          _context6.next = 11;\n                          break;\n                        }\n                        _response$data$ = response.data[0], symbolname = _response$data$.symbolname, lastprice = _response$data$.lastprice, ask = _response$data$.ask, bid = _response$data$.bid, volume = _response$data$.volume; // Remove suffix before returning to client\n                        symbolWithoutSuffix = _this4.removeSuffix(symbolname);\n                        return _context6.abrupt(\"return\", {\n                          n: symbolWithoutSuffix,\n                          s: \"ok\",\n                          v: {\n                            ch: 0,\n                            chp: 0,\n                            short_name: symbolWithoutSuffix,\n                            exchange: \"\",\n                            description: symbolWithoutSuffix,\n                            lp: lastprice,\n                            ask: ask,\n                            bid: bid,\n                            open_price: lastprice,\n                            high_price: lastprice,\n                            low_price: lastprice,\n                            prev_close_price: lastprice,\n                            volume: volume\n                          }\n                        });\n                      case 11:\n                        throw new Error(\"Response unsuccessful or no data\");\n                      case 14:\n                        _context6.prev = 14;\n                        _context6.t0 = _context6[\"catch\"](0);\n                        console.error(\"[getQuotes]: Failed to get quote for \".concat(symbol, \", error=\"), _context6.t0);\n                        return _context6.abrupt(\"return\", {\n                          n: symbol,\n                          s: \"error\",\n                          v: {\n                            ch: 0,\n                            chp: 0,\n                            short_name: symbol,\n                            exchange: \"\",\n                            description: \"No Data\",\n                            lp: 0,\n                            ask: 0,\n                            bid: 0,\n                            open_price: 0,\n                            high_price: 0,\n                            low_price: 0,\n                            prev_close_price: 0,\n                            volume: 0\n                          }\n                        });\n                      case 18:\n                      case \"end\":\n                        return _context6.stop();\n                    }\n                  }, _callee6, null, [[0, 14]]);\n                }));\n                return function (_x19) {\n                  return _ref2.apply(this, arguments);\n                };\n              }()));\n            case 3:\n              quotes = _context7.sent;\n              onDataCallback(quotes);\n              _context7.next = 11;\n              break;\n            case 7:\n              _context7.prev = 7;\n              _context7.t0 = _context7[\"catch\"](0);\n              console.error(\"[getQuotes]: Failed to get quotes, error=\", _context7.t0);\n              onErrorCallback(_context7.t0.toString());\n            case 11:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, null, [[0, 7]]);\n      }));\n      function getQuotes(_x16, _x17, _x18) {\n        return _getQuotes.apply(this, arguments);\n      }\n      return getQuotes;\n    }()\n  }, {\n    key: \"subscribeQuotes\",\n    value: function subscribeQuotes(symbols, fastSymbols, onRealtimeCallback, listenerGUID) {\n      var _this5 = this;\n      console.log(\"[subscribeQuotes]: Method call with listenerGUID:\", listenerGUID, symbols, fastSymbols);\n      fastSymbols.forEach(function (symbol) {\n        // Append suffix to the symbol\n        var symbolWithSuffix = _this5.appendSuffix(symbol);\n        _streaming_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setSubscriber(\"GetQuotes\", listenerGUID, symbolWithSuffix, function (data) {\n          if (Array.isArray(data)) {\n            onRealtimeCallback(data);\n          } else {\n            // console.error(\"[subscribeQuotes]: Unexpected data type\", data);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"unsubscribeQuotes\",\n    value: function unsubscribeQuotes(listenerGUID) {\n      _streaming_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].removeSubscriber(listenerGUID);\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Datafeed);\n\n//# sourceURL=webpack://trading_terminal/./src/datafeed.js?");

/***/ }),

/***/ "./src/helpers.js":
/*!************************!*\
  !*** ./src/helpers.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateSymbol: () => (/* binding */ generateSymbol),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   getToken: () => (/* binding */ getToken),\n/* harmony export */   logMessage: () => (/* binding */ logMessage),\n/* harmony export */   makeApiRequest: () => (/* binding */ makeApiRequest),\n/* harmony export */   makePostApiRequest: () => (/* binding */ makePostApiRequest),\n/* harmony export */   parseFullSymbol: () => (/* binding */ parseFullSymbol)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n/**\n * If you want to enable logs from datafeed set it to `true`\n */\n\nvar isLoggingEnabled = false;\n\n/**\n * Logs a message to the console if logging is enabled.\n * @param {string} message - The message to log.\n */\nfunction logMessage(message) {\n  if (isLoggingEnabled) {\n    var now = new Date();\n    // tslint:disable-next-line:no-console\n    // console.log(\n    //   `${now.toLocaleTimeString()}.${now.getMilliseconds()}> ${message}`\n    // );\n  }\n}\nfunction getErrorMessage(error) {\n  if (error === undefined) {\n    return \"\";\n  } else if (typeof error === \"string\") {\n    return error;\n  }\n  return error.message;\n}\nfunction makeApiRequest(_x, _x2) {\n  return _makeApiRequest.apply(this, arguments);\n}\n\n// export async function getCRMToken() {\n//   try {\n//     const data = await makePostApiRequest(`api/Authentication/crmlogin`, {\n//       email: CRM_EMAIL,\n//       password: CRM_PASSWORD,\n//       rememberMe: true,\n//     });\n//     localStorage.setItem(\"crm_token\", data?.token);\n//     return data.token;\n//   } catch (error) {\n//     // console.error(\"[getToken]: Fail to load server Token, error=\", error);\n//   }\n// }\nfunction _makeApiRequest() {\n  _makeApiRequest = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(path, params) {\n    var paramKeys, headers, response;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (params !== undefined) {\n            paramKeys = Object.keys(params);\n            if (paramKeys.length !== 0) {\n              path += \"?\";\n            }\n            path += paramKeys.map(function (key) {\n              return \"\".concat(encodeURIComponent(key), \"=\").concat(encodeURIComponent(params[key].toString()));\n            }).join(\"&\");\n          }\n          headers = {\n            Authorization: \"Bearer \".concat(localStorage.getItem(\"token\"))\n          };\n          _context.next = 4;\n          return fetch(\"\".concat(\"https://opotrade.azurewebsites.net/\").concat(path), {\n            headers: headers\n          });\n        case 4:\n          response = _context.sent;\n          return _context.abrupt(\"return\", response.json());\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _makeApiRequest.apply(this, arguments);\n}\nfunction getToken(_x3) {\n  return _getToken.apply(this, arguments);\n}\nfunction _getToken() {\n  _getToken = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(crmToken) {\n    var data;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.prev = 0;\n          _context2.next = 3;\n          return makePostApiRequest(\"api/Authentication/login\", {\n            username: \"test\",\n            password: \"password\",\n            crmToken: localStorage.getItem(\"crm_token\")\n          });\n        case 3:\n          data = _context2.sent;\n          localStorage.setItem(\"token\", data === null || data === void 0 ? void 0 : data.token);\n          return _context2.abrupt(\"return\", data.token);\n        case 8:\n          _context2.prev = 8;\n          _context2.t0 = _context2[\"catch\"](0);\n        case 10:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[0, 8]]);\n  }));\n  return _getToken.apply(this, arguments);\n}\nfunction makePostApiRequest(_x4, _x5) {\n  return _makePostApiRequest.apply(this, arguments);\n}\n\n// Generates a symbol ID from a pair of the coins\nfunction _makePostApiRequest() {\n  _makePostApiRequest = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(path, body) {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return fetch(\"\".concat(\"https://opotrade.azurewebsites.net/\").concat(path), {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body)\n          });\n        case 2:\n          response = _context3.sent;\n          return _context3.abrupt(\"return\", response.json());\n        case 4:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _makePostApiRequest.apply(this, arguments);\n}\nfunction generateSymbol(exchange, fromSymbol, toSymbol) {\n  var _short = \"\".concat(fromSymbol, \"/\").concat(toSymbol);\n  return {\n    \"short\": _short,\n    full: \"\".concat(exchange, \":\").concat(_short)\n  };\n}\n\n// Returns all parts of the symbol\nfunction parseFullSymbol(fullSymbol) {\n  var match = fullSymbol.match(/^(\\w+):(\\w+)\\/(\\w+)$/);\n  if (!match) {\n    return null;\n  }\n  return {\n    exchange: match[1],\n    fromSymbol: match[2],\n    toSymbol: match[3]\n  };\n}\n\n//# sourceURL=webpack://trading_terminal/./src/helpers.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _datafeed_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datafeed.js */ \"./src/datafeed.js\");\n/* harmony import */ var _broker_sample_lib_broker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../broker-sample/lib/broker.js */ \"./broker-sample/lib/broker.js\");\n/* harmony import */ var _token_manager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./token_manager.js */ \"./src/token_manager.js\");\n/* harmony import */ var _save_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./save.js */ \"./src/save.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n// main.js\n\n\n\n\n\nfunction initTradingViewWidget() {\n  return _initTradingViewWidget.apply(this, arguments);\n}\nfunction _initTradingViewWidget() {\n  _initTradingViewWidget = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var token, AuthenticatedDatafeed, autoSaveContent, saveLoadAdapter;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          _context.next = 3;\n          return _token_manager_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getToken();\n        case 3:\n          token = _context.sent;\n          if (!token) {\n            _context.next = 19;\n            break;\n          }\n          AuthenticatedDatafeed = /*#__PURE__*/function (_Datafeed) {\n            function AuthenticatedDatafeed() {\n              var _this;\n              _classCallCheck(this, AuthenticatedDatafeed);\n              _this = _callSuper(this, AuthenticatedDatafeed);\n              _this.tokenManager = _token_manager_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n              return _this;\n            }\n            _inherits(AuthenticatedDatafeed, _Datafeed);\n            return _createClass(AuthenticatedDatafeed);\n          }(_datafeed_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n          autoSaveContent = null;\n          saveLoadAdapter = new _save_js__WEBPACK_IMPORTED_MODULE_3__.SaveLoadAdapter();\n          _context.prev = 8;\n          _context.next = 11;\n          return saveLoadAdapter.loadAutoSaveChart();\n        case 11:\n          autoSaveContent = _context.sent;\n          _context.next = 17;\n          break;\n        case 14:\n          _context.prev = 14;\n          _context.t0 = _context[\"catch\"](8);\n          console.log(\"No auto-save found, starting with a fresh chart\");\n        case 17:\n          window.tvWidget = new TradingView.widget({\n            symbol: \"XAUUSD\",\n            interval: \"1\",\n            fullscreen: true,\n            container: \"tv_chart_container\",\n            datafeed: new AuthenticatedDatafeed(),\n            library_path: \"../charting_library/\",\n            debug: true,\n            theme: \"dark\",\n            timezone: \"Europe/Istanbul\",\n            disabled_features: [\"header_undo_redo\", \"header_quick_search\", \"header_fullscreen_button\", \"adaptive_logo\", \"dom_widget\", \"support_multicharts\", \"header_layouttoggle\"],\n            broker_factory: function broker_factory(host) {\n              return new _broker_sample_lib_broker_js__WEBPACK_IMPORTED_MODULE_1__.BrokerSample(host, new AuthenticatedDatafeed());\n            },\n            broker_config: {\n              configFlags: {\n                supportPositions: true,\n                supportClosePosition: true,\n                supportOrderBrackets: true,\n                supportPositionBrackets: true,\n                editPositionBrackets: true,\n                supportEditAmount: false,\n                supportOrdersHistory: true,\n                supportNativeReversePosition: true\n              }\n            },\n            save_load_adapter: saveLoadAdapter,\n            widgetbar: {\n              datawindow: true,\n              watchlist: true,\n              details: true,\n              watchlist_settings: {\n                default_symbols: [\"NZDUSD\", \"USDJPY\", \"USDCHF\"],\n                readonly: false\n              }\n            }\n          });\n          window.tvWidget.onChartReady(function () {\n            if (autoSaveContent) {\n              window.tvWidget.load(autoSaveContent);\n            }\n            setInterval(function () {\n              window.tvWidget.save(function (chartData) {\n                saveLoadAdapter.saveAutoSaveChart(chartData);\n              });\n            }, 4000);\n          });\n        case 19:\n          _context.next = 24;\n          break;\n        case 21:\n          _context.prev = 21;\n          _context.t1 = _context[\"catch\"](0);\n          console.error(\"Error initializing TradingView:\", _context.t1);\n        case 24:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[0, 21], [8, 14]]);\n  }));\n  return _initTradingViewWidget.apply(this, arguments);\n}\ninitTradingViewWidget();\n\n//# sourceURL=webpack://trading_terminal/./src/main.js?");

/***/ }),

/***/ "./src/save.js":
/*!*********************!*\
  !*** ./src/save.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SaveLoadAdapter: () => (/* binding */ SaveLoadAdapter)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// SaveLoadAdapter.js\n\nvar SaveLoadAdapter = /*#__PURE__*/function () {\n  function SaveLoadAdapter() {\n    _classCallCheck(this, SaveLoadAdapter);\n    this.storageKeys = {\n      charts: 'tvCharts',\n      autoSaveChart: 'tvAutoSaveChart',\n      // Add this line\n      studyTemplates: 'tvStudyTemplates',\n      drawingTemplates: 'tvDrawingTemplates',\n      chartTemplates: 'tvChartTemplates',\n      drawings: 'tvDrawings'\n    };\n    this.loadFromLocalStorage();\n  }\n  return _createClass(SaveLoadAdapter, [{\n    key: \"loadFromLocalStorage\",\n    value: function loadFromLocalStorage() {\n      this.charts = JSON.parse(localStorage.getItem(this.storageKeys.charts) || '[]');\n      this.studyTemplates = JSON.parse(localStorage.getItem(this.storageKeys.studyTemplates) || '[]');\n      this.drawingTemplates = JSON.parse(localStorage.getItem(this.storageKeys.drawingTemplates) || '[]');\n      this.chartTemplates = JSON.parse(localStorage.getItem(this.storageKeys.chartTemplates) || '[]');\n      this.drawings = JSON.parse(localStorage.getItem(this.storageKeys.drawings) || '{}');\n    }\n  }, {\n    key: \"saveToLocalStorage\",\n    value: function saveToLocalStorage(key) {\n      localStorage.setItem(this.storageKeys[key], JSON.stringify(this[key]));\n    }\n  }, {\n    key: \"getAllCharts\",\n    value: function getAllCharts() {\n      return Promise.resolve(this.charts);\n    }\n  }, {\n    key: \"removeChart\",\n    value: function removeChart(id) {\n      this.charts = this.charts.filter(function (chart) {\n        return chart.id !== id;\n      });\n      this.saveToLocalStorage('charts');\n      return Promise.resolve();\n    }\n  }, {\n    key: \"saveChart\",\n    value: function saveChart(chartData) {\n      if (!chartData.id) {\n        chartData.id = Math.random().toString();\n      } else {\n        this.removeChart(chartData.id);\n      }\n      var savedChartData = _objectSpread(_objectSpread({}, chartData), {}, {\n        id: chartData.id,\n        timestamp: Math.round(Date.now() / 1000)\n      });\n      this.charts.push(savedChartData);\n      this.saveToLocalStorage('charts');\n      return Promise.resolve(chartData.id);\n    }\n  }, {\n    key: \"getChartContent\",\n    value: function getChartContent(id) {\n      var chart = this.charts.find(function (chart) {\n        return chart.id === id;\n      });\n      return chart ? Promise.resolve(chart.content) : Promise.reject(new Error(\"Chart not found\"));\n    }\n  }, {\n    key: \"getAllStudyTemplates\",\n    value: function getAllStudyTemplates() {\n      return Promise.resolve(this.studyTemplates);\n    }\n  }, {\n    key: \"removeStudyTemplate\",\n    value: function removeStudyTemplate(studyTemplateInfo) {\n      this.studyTemplates = this.studyTemplates.filter(function (template) {\n        return template.name !== studyTemplateInfo.name;\n      });\n      this.saveToLocalStorage('studyTemplates');\n      return Promise.resolve();\n    }\n  }, {\n    key: \"saveStudyTemplate\",\n    value: function saveStudyTemplate(studyTemplateData) {\n      var index = this.studyTemplates.findIndex(function (template) {\n        return template.name === studyTemplateData.name;\n      });\n      if (index !== -1) {\n        this.studyTemplates[index] = studyTemplateData;\n      } else {\n        this.studyTemplates.push(studyTemplateData);\n      }\n      this.saveToLocalStorage('studyTemplates');\n      return Promise.resolve();\n    }\n  }, {\n    key: \"getStudyTemplateContent\",\n    value: function getStudyTemplateContent(studyTemplateInfo) {\n      var template = this.studyTemplates.find(function (template) {\n        return template.name === studyTemplateInfo.name;\n      });\n      return template ? Promise.resolve(template.content) : Promise.reject(new Error(\"Study template not found\"));\n    }\n  }, {\n    key: \"getDrawingTemplates\",\n    value: function getDrawingTemplates(toolName) {\n      return Promise.resolve(this.drawingTemplates.filter(function (template) {\n        return template.toolName === toolName;\n      }).map(function (template) {\n        return template.name;\n      }));\n    }\n  }, {\n    key: \"loadDrawingTemplate\",\n    value: function loadDrawingTemplate(toolName, templateName) {\n      var template = this.drawingTemplates.find(function (template) {\n        return template.toolName === toolName && template.name === templateName;\n      });\n      return template ? Promise.resolve(template.content) : Promise.reject(new Error(\"Drawing template not found\"));\n    }\n  }, {\n    key: \"removeDrawingTemplate\",\n    value: function removeDrawingTemplate(toolName, templateName) {\n      this.drawingTemplates = this.drawingTemplates.filter(function (template) {\n        return !(template.toolName === toolName && template.name === templateName);\n      });\n      this.saveToLocalStorage('drawingTemplates');\n      return Promise.resolve();\n    }\n  }, {\n    key: \"saveDrawingTemplate\",\n    value: function saveDrawingTemplate(toolName, templateName, content) {\n      var index = this.drawingTemplates.findIndex(function (template) {\n        return template.toolName === toolName && template.name === templateName;\n      });\n      if (index !== -1) {\n        this.drawingTemplates[index] = {\n          toolName: toolName,\n          name: templateName,\n          content: content\n        };\n      } else {\n        this.drawingTemplates.push({\n          toolName: toolName,\n          name: templateName,\n          content: content\n        });\n      }\n      this.saveToLocalStorage('drawingTemplates');\n      return Promise.resolve();\n    }\n  }, {\n    key: \"getAllChartTemplates\",\n    value: function getAllChartTemplates() {\n      return Promise.resolve(this.chartTemplates.map(function (template) {\n        return template.name;\n      }));\n    }\n  }, {\n    key: \"saveChartTemplate\",\n    value: function saveChartTemplate(templateName, content) {\n      var index = this.chartTemplates.findIndex(function (template) {\n        return template.name === templateName;\n      });\n      if (index !== -1) {\n        this.chartTemplates[index].content = content;\n      } else {\n        this.chartTemplates.push({\n          name: templateName,\n          content: content\n        });\n      }\n      this.saveToLocalStorage('chartTemplates');\n      return Promise.resolve();\n    }\n  }, {\n    key: \"getChartTemplateContent\",\n    value: function getChartTemplateContent(templateName) {\n      var template = this.chartTemplates.find(function (template) {\n        return template.name === templateName;\n      });\n      return template ? Promise.resolve({\n        content: JSON.parse(JSON.stringify(template.content))\n      }) : Promise.reject(new Error(\"Chart template not found\"));\n    }\n  }, {\n    key: \"saveLineToolsAndGroups\",\n    value: function saveLineToolsAndGroups(layoutId, chartId, state) {\n      var drawings = state.sources;\n      if (!this.drawings[\"\".concat(layoutId, \"/\").concat(chartId)]) {\n        this.drawings[\"\".concat(layoutId, \"/\").concat(chartId)] = {};\n      }\n      var _iterator = _createForOfIteratorHelper(drawings),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            key = _step$value[0],\n            _state = _step$value[1];\n          if (_state === null) {\n            delete this.drawings[\"\".concat(layoutId, \"/\").concat(chartId)][key];\n          } else {\n            this.drawings[\"\".concat(layoutId, \"/\").concat(chartId)][key] = _state;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.saveToLocalStorage('drawings');\n      return Promise.resolve();\n    }\n  }, {\n    key: \"loadLineToolsAndGroups\",\n    value: function loadLineToolsAndGroups(layoutId, chartId, requestType, requestContext) {\n      var rawSources = this.drawings[\"\".concat(layoutId, \"/\").concat(chartId)];\n      if (!rawSources) return Promise.resolve(null);\n      var sources = new Map();\n      for (var _i = 0, _Object$entries = Object.entries(rawSources); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          key = _Object$entries$_i[0],\n          state = _Object$entries$_i[1];\n        sources.set(key, state);\n      }\n      return Promise.resolve({\n        sources: sources\n      });\n    }\n  }, {\n    key: \"saveAutoSaveChart\",\n    value: function saveAutoSaveChart(chartData) {\n      localStorage.setItem(this.storageKeys.autoSaveChart, JSON.stringify(chartData));\n      return Promise.resolve();\n    }\n  }, {\n    key: \"loadAutoSaveChart\",\n    value: function loadAutoSaveChart() {\n      var chartData = JSON.parse(localStorage.getItem(this.storageKeys.autoSaveChart));\n      return chartData ? Promise.resolve(chartData) : Promise.reject(new Error(\"No auto-save found\"));\n    }\n  }, {\n    key: \"removeAutoSaveChart\",\n    value: function removeAutoSaveChart() {\n      localStorage.removeItem(this.storageKeys.autoSaveChart);\n      return Promise.resolve();\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://trading_terminal/./src/save.js?");

/***/ }),

/***/ "./src/streaming.js":
/*!**************************!*\
  !*** ./src/streaming.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// const WEB_SOCKET_URL = \"wss://oposocket.azurewebsites.net\";\nvar Streaming = /*#__PURE__*/function () {\n  function Streaming() {\n    _classCallCheck(this, Streaming);\n    this.wsInstances = {};\n    this.subscribers = {};\n  }\n  return _createClass(Streaming, [{\n    key: \"setSubscriber\",\n    value: function setSubscriber(type, listenerGUID, symbol, callback) {\n      this.subscribers[listenerGUID] = _objectSpread(_objectSpread({\n        type: type,\n        symbol: symbol\n      }, type === \"GetQuotes\" && {\n        getQuotesCallback: callback\n      }), type === \"GetM1History\" && {\n        getBarsCallback: callback\n      });\n      var url = \"\";\n      if (type === \"GetQuotes\") {\n        url = \"\".concat(\"wss://opotrade.azurewebsites.net/\", \"/ws?symbol=\").concat(symbol, \"&id=1&methodtype=\").concat(type, \"&TP=1&source=tv\");\n      } else if (type === \"GetM1History\") {\n        url = \"\".concat(\"wss://opotrade.azurewebsites.net/\", \"/ws?symbol=\").concat(symbol, \"&fromtime=0&totime=1&data=dhloc&source=tv&methodtype=GetM1History&TP=1\");\n      }\n      this.connectWebSocket(url, type, symbol);\n    }\n  }, {\n    key: \"removeSubscriber\",\n    value: function removeSubscriber(listenerGUID) {\n      if (this.subscribers[listenerGUID]) {\n        var _this$subscribers$lis = this.subscribers[listenerGUID],\n          type = _this$subscribers$lis.type,\n          symbol = _this$subscribers$lis.symbol;\n        delete this.subscribers[listenerGUID];\n        var hasOtherSubscribers = Object.values(this.subscribers).some(function (sub) {\n          return sub.type === type && sub.symbol === symbol;\n        });\n        var wsKey = \"\".concat(type, \"_\").concat(symbol);\n        if (!hasOtherSubscribers && this.wsInstances[wsKey]) {\n          this.wsInstances[wsKey].close();\n          delete this.wsInstances[wsKey];\n        }\n      }\n    }\n  }, {\n    key: \"connectWebSocket\",\n    value: function connectWebSocket(url, type, symbol) {\n      var _this = this;\n      var wsKey = \"\".concat(type, \"_\").concat(symbol);\n      if (!this.wsInstances[wsKey] || this.wsInstances[wsKey].readyState !== WebSocket.OPEN) {\n        if (this.wsInstances[wsKey]) {\n          this.wsInstances[wsKey].close();\n        }\n        this.wsInstances[wsKey] = new WebSocket(url);\n        this.wsInstances[wsKey].onopen = function () {};\n        this.wsInstances[wsKey].onmessage = function (event) {\n          var data = JSON.parse(event.data);\n          if (type === \"GetQuotes\") {\n            _this.processGetQuotesMessage(data, symbol);\n          } else if (type === \"GetM1History\") {\n            _this.processSubscribeBarsMessage(data, symbol);\n          }\n        };\n        this.wsInstances[wsKey].onerror = function (error) {};\n        this.wsInstances[wsKey].onclose = function () {};\n      }\n    }\n  }, {\n    key: \"processGetQuotesMessage\",\n    value: function processGetQuotesMessage(data, symbol) {\n      if (data && data.length > 0) {\n        var quote = data[0];\n        var quoteData = {\n          n: quote.symbolname,\n          s: \"ok\",\n          v: {\n            ch: 0,\n            chp: 0,\n            short_name: quote.symbolname,\n            exchange: \"\",\n            description: quote.symbolname,\n            lp: quote.lastprice,\n            ask: quote.ask,\n            bid: quote.bid,\n            open_price: quote.lastprice,\n            high_price: quote.lastprice,\n            low_price: quote.lastprice,\n            prev_close_price: quote.lastprice,\n            volume: quote.volume\n          }\n        };\n        Object.values(this.subscribers).forEach(function (sub) {\n          if (sub.type === \"GetQuotes\" && sub.symbol === quote.symbolname && sub.getQuotesCallback) {\n            sub.getQuotesCallback([quoteData]);\n          }\n        });\n      } else {\n        var _quoteData = {\n          n: symbol,\n          s: \"error\",\n          v: {\n            ch: 0,\n            chp: 0,\n            short_name: symbol,\n            exchange: \"\",\n            description: \"No Data\",\n            lp: 0,\n            ask: 0,\n            bid: 0,\n            open_price: 0,\n            high_price: 0,\n            low_price: 0,\n            prev_close_price: 0,\n            volume: 0\n          }\n        };\n        Object.values(this.subscribers).forEach(function (sub) {\n          if (sub.type === \"GetQuotes\" && sub.symbol === symbol && sub.getQuotesCallback) {\n            sub.getQuotesCallback([_quoteData]);\n          }\n        });\n      }\n    }\n  }, {\n    key: \"processSubscribeBarsMessage\",\n    value: function processSubscribeBarsMessage(data, symbol) {\n      if (Array.isArray(data) && data.length > 0) {\n        var lastBar = data[data.length - 1];\n        if (lastBar && _typeof(lastBar) === \"object\" && \"time\" in lastBar) {\n          var bar = {\n            time: (lastBar.time - 10800) * 1000,\n            // Adjust time as needed\n            close: parseFloat(lastBar.close),\n            open: parseFloat(lastBar.open),\n            high: parseFloat(lastBar.high),\n            low: parseFloat(lastBar.low),\n            volume: parseFloat(lastBar.volume)\n          };\n          Object.values(this.subscribers).forEach(function (sub) {\n            if (sub.type === \"GetM1History\" && sub.symbol === symbol && sub.getBarsCallback) {\n              sub.getBarsCallback(bar);\n            }\n          });\n        } else {\n          console.error(\"Invalid last bar data:\", lastBar);\n        }\n      } else {\n        console.error(\"Invalid data received in processSubscribeBarsMessage:\", data);\n      }\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Streaming());\n\n//# sourceURL=webpack://trading_terminal/./src/streaming.js?");

/***/ }),

/***/ "./src/token_manager.js":
/*!******************************!*\
  !*** ./src/token_manager.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"./src/helpers.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar TokenManager = /*#__PURE__*/function () {\n  function TokenManager() {\n    _classCallCheck(this, TokenManager);\n    this.token = null; // Cache the token\n    this.tokenPromise = null; // Cache the in-flight promise to avoid multiple requests\n  }\n  return _createClass(TokenManager, [{\n    key: \"getToken\",\n    value: function () {\n      var _getToken2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var token;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this.token !== null)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", this.token);\n            case 2:\n              if (!this.tokenPromise) {\n                _context.next = 4;\n                break;\n              }\n              return _context.abrupt(\"return\", this.tokenPromise);\n            case 4:\n              token = localStorage.getItem(\"crm_token\");\n              this.tokenPromise = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.getToken)(token);\n              _context.prev = 6;\n              _context.next = 9;\n              return this.tokenPromise;\n            case 9:\n              this.token = _context.sent;\n              _context.next = 17;\n              break;\n            case 12:\n              _context.prev = 12;\n              _context.t0 = _context[\"catch\"](6);\n              // In case of failure, clear the tokenPromise and rethrow the error\n              console.error(\"Failed to fetch token:\", _context.t0);\n              this.tokenPromise = null;\n              throw _context.t0;\n            case 17:\n              // Clear the promise once the token is fetched\n              this.tokenPromise = null;\n              return _context.abrupt(\"return\", this.token);\n            case 19:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[6, 12]]);\n      }));\n      function getToken() {\n        return _getToken2.apply(this, arguments);\n      }\n      return getToken;\n    }() // Optional: Method to manually reset or invalidate the token\n  }, {\n    key: \"invalidateToken\",\n    value: function invalidateToken() {\n      this.token = null;\n    }\n  }]);\n}();\nvar tokenManager = new TokenManager();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (tokenManager);\n\n//# sourceURL=webpack://trading_terminal/./src/token_manager.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;